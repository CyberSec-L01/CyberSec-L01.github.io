<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MarkDown_Math</title>
    <link href="/2023/06/03/markdown_math/"/>
    <url>/2023/06/03/markdown_math/</url>
    
    <content type="html"><![CDATA[<blockquote><p>右键点击每一个公式，选择 <strong>[Show Math As] → [TeXCommands]</strong> 以查看该公式的命令详情。</p></blockquote><p>[TOC]</p><hr><h1 id="一公式使用参考">一、公式使用参考</h1><h2 id="插入公式">1．插入公式</h2><p><span class="math inline">\(\LaTeX\)</span>的数学公式有两种：行中公式和独立公式。行中公式放在文中与其它文字混编，独立公式单独成行。</p><dl><dt>行中公式可以用如下方法表示：</dt><dd><pre><code class="hljs"> $ 数学公式 $</code></pre></dd><dt>独立公式可以用如下方法表示：</dt><dd><pre><code class="hljs"> $$ 数学公式 $$</code></pre></dd></dl><h2 id="输入上下标">2．输入上下标</h2><p><code>^</code> 表示上标, <code>_</code>表示下标。如果上下标的内容多于一个字符，需要用 <code>&#123;&#125;</code>将这些内容括成一个整体。上下标可以嵌套，也可以同时使用。</p><ul><li>例子：</li></ul><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span> x^&#123;y^z&#125;=(<span class="hljs-number">1</span>+&#123;\rm e&#125;^x)^&#123;<span class="hljs-number">-2</span>xy^w&#125; <span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><ul><li>显示：</li></ul><p><span class="math display">\[ x^{y^z}=(1+{\rm e}^x)^{-2xy^w}\]</span></p><p>另外，如果要在左右两边都有上下标，可以使用 <code>\sideset</code>命令；也可以简单地在符号前面多打一个上下标，此时会以行内公式渲染。</p><h2 id="输入括号和分隔符">3．输入括号和分隔符</h2><p><code>()</code>、<code>[]</code> 和 <code>|</code> 表示符号本身，使用<code>\&#123;\&#125;</code> 来表示 <code>&#123;&#125;</code>。当要显示大号的括号或分隔符时，要用 <code>\left</code> 和<code>\right</code> 命令。</p><p>一些特殊的括号：</p><table><thead><tr class="header"><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>\langle</code></td><td style="text-align: center;"><span class="math inline">\(\langle\)</span></td><td style="text-align: center;"><code>\rangle</code></td><td style="text-align: center;"><span class="math inline">\(\rangle\)</span></td></tr><tr class="even"><td style="text-align: center;"><code>\lceil</code></td><td style="text-align: center;"><span class="math inline">\(\lceil\)</span></td><td style="text-align: center;"><code>\rceil</code></td><td style="text-align: center;"><span class="math inline">\(\rceil\)</span></td></tr><tr class="odd"><td style="text-align: center;"><code>\lfloor</code></td><td style="text-align: center;"><span class="math inline">\(\lfloor\)</span></td><td style="text-align: center;"><code>\rfloor</code></td><td style="text-align: center;"><span class="math inline">\(\rfloor\)</span></td></tr><tr class="even"><td style="text-align: center;"><code>\lbrace</code></td><td style="text-align: center;"><span class="math inline">\(\lbrace\)</span></td><td style="text-align: center;"><code>\rbrace</code></td><td style="text-align: center;"><span class="math inline">\(\rbrace\)</span></td></tr><tr class="odd"><td style="text-align: center;"><code>\lvert</code></td><td style="text-align: center;"><span class="math inline">\(\lvert\)</span></td><td style="text-align: center;"><code>\rvert</code></td><td style="text-align: center;"><span class="math inline">\(\rvert\)</span></td></tr><tr class="even"><td style="text-align: center;"><code>\lVert</code></td><td style="text-align: center;"><span class="math inline">\(\lVert\)</span></td><td style="text-align: center;"><code>\rVert</code></td><td style="text-align: center;"><span class="math inline">\(\rVert\)</span></td></tr></tbody></table><ul><li>例子：</li></ul><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span> f(x,y,z) = <span class="hljs-number">3</span>y^<span class="hljs-number">2</span>z \left( <span class="hljs-number">3</span>+\<span class="hljs-built_in">frac</span>&#123;<span class="hljs-number">7</span>x+<span class="hljs-number">5</span>&#125;&#123;<span class="hljs-number">1</span>+y^<span class="hljs-number">2</span>&#125; \right) <span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><ul><li>显示：</li></ul><p><span class="math display">\[ f(x,y,z) = 3y^2z \left(3+\frac{7x+5}{1+y^2} \right) \]</span></p><p>有时要用 <code>\left.</code> 或 <code>\right.</code>进行匹配而不显示本身。</p><h2 id="输入分数">4．输入分数</h2><p>通常使用 <code>\frac &#123;分子&#125; &#123;分母&#125;</code>来生成一个分数，分数可多层嵌套。如果分式较为复杂，亦可使用<code>分子 \over 分母</code> 此时分数仅有一层。</p><ul><li>例子：</li></ul><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span> \<span class="hljs-built_in">frac</span>&#123;a<span class="hljs-number">-1</span>&#125;&#123;b<span class="hljs-number">-1</span>&#125; \quad <span class="hljs-keyword">or</span> \quad &#123;a+<span class="hljs-number">1</span> \over b+<span class="hljs-number">1</span>&#125; <span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><ul><li>显示：</li></ul><p><span class="math display">\[ \frac{a-1}{b-1} \quad or \quad {a+1\over b+1} \]</span></p><p>当分式 <strong>仅有两个字符时</strong> 可直接输入<code>\frac ab</code> 来快速生成一个 <span class="math inline">\(\large\frac ab\)</span> 。</p><ul><li>例子：</li></ul><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">$$ <span class="hljs-string">\frac</span> <span class="hljs-number">12</span>,<span class="hljs-string">\frac</span> <span class="hljs-number">1a</span>,<span class="hljs-string">\frac</span> a2 <span class="hljs-string">\quad</span> <span class="hljs-string">\mid</span> <span class="hljs-string">\quad</span> <span class="hljs-string">\text&#123;2</span> letters only:&#125; <span class="hljs-string">\quad</span> <span class="hljs-string">\frac</span> <span class="hljs-number">12a</span> <span class="hljs-string">\,,</span> k<span class="hljs-string">\frac</span> q&#123;r^<span class="hljs-number">2</span>&#125; $$<br></code></pre></td></tr></table></figure><ul><li>显示：</li></ul><p><span class="math display">\[ \frac 12,\frac 1a,\frac a2 \quad \mid\quad \text{2 letters only:} \quad \frac 12a \,, k\frac q{r^2}\]</span></p><h2 id="输入开方">5．输入开方</h2><p>使用 <code>\sqrt [根指数，省略时为2] &#123;被开方数&#125;</code>命令输入开方。</p><ul><li>例子：</li></ul><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span> \<span class="hljs-built_in">sqrt</span>&#123;<span class="hljs-number">2</span>&#125; \quad <span class="hljs-keyword">or</span> \quad \<span class="hljs-built_in">sqrt</span>[n]&#123;<span class="hljs-number">3</span>&#125; <span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><ul><li>显示：</li></ul><p><span class="math display">\[ \sqrt{2} \quad or \quad \sqrt[n]{3}\]</span></p><h2 id="输入省略号">6．输入省略号</h2><p>数学公式中常见的省略号有两种，<code>\ldots</code> 表示与<strong>文本底线</strong> 对齐的省略号，<code>\cdots</code> 表示与<strong>文本中线</strong> 对齐的省略号。</p><ul><li>例子：</li></ul><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">$$ f(x_1,x_2,\underbrace</span><span class="hljs-template-variable">&#123;\ldots&#125;</span><span class="language-xml">_</span><span class="hljs-template-variable">&#123;\rm ldots&#125;</span><span class="language-xml"> ,x_n) = x_1^2 + x_2^2 + \underbrace</span><span class="hljs-template-variable">&#123;\cdots&#125;</span><span class="language-xml">_</span><span class="hljs-template-variable">&#123;\rm cdots&#125;</span><span class="language-xml"> + x_n^2 $$</span><br></code></pre></td></tr></table></figure><ul><li>显示：</li></ul><p><span class="math display">\[ f(x_1,x_2,\underbrace{\ldots}_{\rmldots} ,x_n) = x_1^2 + x_2^2 + \underbrace{\cdots}_{\rm cdots} + x_n^2\]</span></p><h2 id="输入向量">7．输入向量</h2><p>使用 <code>\vec&#123;向量&#125;</code> 来自动产生一个向量。也可以使用<code>\overrightarrow</code> 等命令自定义字母上方的符号。</p><ul><li>例子：</li></ul><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span> \vec&#123;a&#125; \cdot \vec&#123;b&#125;=<span class="hljs-number">0</span> <span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><ul><li>显示：</li></ul><p><span class="math display">\[ \vec{a} \cdot \vec{b}=0 \]</span></p><ul><li>例子：</li></ul><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">$$ xy <span class="hljs-string">\text&#123;</span> <span class="hljs-keyword">with</span> arrows:&#125; <span class="hljs-string">\quad</span> <span class="hljs-string">\overleftarrow&#123;xy&#125;</span> <span class="hljs-string">\;</span> <span class="hljs-string">\mid</span> <span class="hljs-string">\;</span> <span class="hljs-string">\overleftrightarrow&#123;xy&#125;</span> <span class="hljs-string">\;</span> <span class="hljs-string">\mid</span> <span class="hljs-string">\;</span> <span class="hljs-string">\overrightarrow&#123;xy&#125;</span> $$<br></code></pre></td></tr></table></figure><ul><li>显示：</li></ul><p><span class="math display">\[ xy \text{ with arrows:} \quad\overleftarrow{xy} \; \mid \; \overleftrightarrow{xy} \; \mid \;\overrightarrow{xy} \]</span></p><h2 id="输入积分">8．输入积分</h2><p>使用 <code>\int_积分下限^积分上限 &#123;被积表达式&#125;</code>来输入一个积分。</p><ul><li>例子：</li></ul><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span> \int_0^<span class="hljs-number">1</span> &#123;x^<span class="hljs-number">2</span>&#125; \,&#123;\rm d&#125;x <span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><ul><li>显示：</li></ul><p><span class="math display">\[ \int_0^1 {x^2} \,{\rm d}x \]</span></p><p>本例中 <code>\,</code> 和 <code>&#123;\rm d&#125;</code>部分可省略，但加入能使式子更美观，详见“<a href="#3在字符间加入空格">在字符间加入空格</a>”及“<a href="#13如何进行字体转换">如何进行字体转换</a>”。</p><h2 id="输入极限运算">9．输入极限运算</h2><p>使用 <code>\lim_&#123;变量 \to 表达式&#125; 表达式</code>来输入一个极限。如有需求，可以更改 <code>\to</code> 符号至任意符号。</p><ul><li>例子：</li></ul><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">$$ <span class="hljs-string">\lim_&#123;n</span> <span class="hljs-string">\to</span> <span class="hljs-string">\infty&#125;</span> <span class="hljs-string">\frac&#123;1&#125;&#123;n(n+1)&#125;</span> <span class="hljs-string">\quad</span> <span class="hljs-keyword">and</span> <span class="hljs-string">\quad</span> <span class="hljs-string">\lim_&#123;x\leftarrow&#123;示例&#125;&#125;</span> <span class="hljs-string">\frac&#123;1&#125;&#123;n(n+1)&#125;</span> $$<br></code></pre></td></tr></table></figure><ul><li>显示：</li></ul><p><span class="math display">\[ \lim_{n \to \infty} \frac{1}{n(n+1)}\quad and \quad \lim_{x\leftarrow{示例}} \frac{1}{n(n+1)} \]</span></p><h2 id="输入累加累乘运算">10．输入累加、累乘运算</h2><p>使用 <code>\sum_&#123;下标表达式&#125;^&#123;上标表达式&#125; &#123;累加表达式&#125;</code>来输入一个累加。与之类似，使用 <code>\prod</code> <code>\bigcup</code><code>\bigcap</code> 来分别输入累乘、并集和交集，更多符号可参考“<a href="#12如何输入其它特殊字符">其它特殊字符</a>”。此类符号在行内显示时上下标表达式将会移至右上角和右下角，如 <span class="math inline">\(\sum_{i=1}^n \frac{1}{i^2}\)</span>。</p><ul><li>例子：</li></ul><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">$$ <span class="hljs-string">\sum_&#123;i=1&#125;^n</span> <span class="hljs-string">\frac&#123;1&#125;&#123;i^2&#125;</span> <span class="hljs-string">\quad</span> <span class="hljs-keyword">and</span> <span class="hljs-string">\quad</span> <span class="hljs-string">\prod_&#123;i=1&#125;^n</span> <span class="hljs-string">\frac&#123;1&#125;&#123;i^2&#125;</span> <span class="hljs-string">\quad</span> <span class="hljs-keyword">and</span> <span class="hljs-string">\quad</span> <span class="hljs-string">\bigcup_&#123;i=1&#125;^&#123;2&#125;</span> <span class="hljs-string">\Bbb&#123;R&#125;</span> $$<br></code></pre></td></tr></table></figure><ul><li>显示：</li></ul><p><span class="math display">\[ \sum_{i=1}^n \frac{1}{i^2} \quad and\quad \prod_{i=1}^n \frac{1}{i^2} \quad and \quad \bigcup_{i=1}^{2}\Bbb{R} \]</span></p><h2 id="输入希腊字母">11．输入希腊字母</h2><p>输入 <code>\小写希腊字母英文全称</code> 和<code>\首字母大写希腊字母英文全称</code> 来分别输入小写和大写希腊字母。<strong>对于大写希腊字母与现有字母相同的，直接输入大写字母即可。</strong></p><table><thead><tr class="header"><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>\alpha</code></td><td style="text-align: center;"><span class="math inline">\(\alpha\)</span></td><td style="text-align: center;"><code>A</code></td><td style="text-align: center;"><span class="math inline">\(A\)</span></td><td style="text-align: center;"><code>\beta</code></td><td style="text-align: center;"><span class="math inline">\(\beta\)</span></td><td style="text-align: center;"><code>B</code></td><td style="text-align: center;"><span class="math inline">\(B\)</span></td></tr><tr class="even"><td style="text-align: center;"><code>\gamma</code></td><td style="text-align: center;"><span class="math inline">\(\gamma\)</span></td><td style="text-align: center;"><code>\Gamma</code></td><td style="text-align: center;"><span class="math inline">\(\Gamma\)</span></td><td style="text-align: center;"><code>\delta</code></td><td style="text-align: center;"><span class="math inline">\(\delta\)</span></td><td style="text-align: center;"><code>\Delta</code></td><td style="text-align: center;"><span class="math inline">\(\Delta\)</span></td></tr><tr class="odd"><td style="text-align: center;"><code>\epsilon</code></td><td style="text-align: center;"><span class="math inline">\(\epsilon\)</span></td><td style="text-align: center;"><code>E</code></td><td style="text-align: center;"><span class="math inline">\(E\)</span></td><td style="text-align: center;"><code>\zeta</code></td><td style="text-align: center;"><span class="math inline">\(\zeta\)</span></td><td style="text-align: center;"><code>Z</code></td><td style="text-align: center;"><span class="math inline">\(Z\)</span></td></tr><tr class="even"><td style="text-align: center;"><code>\eta</code></td><td style="text-align: center;"><span class="math inline">\(\eta\)</span></td><td style="text-align: center;"><code>H</code></td><td style="text-align: center;"><span class="math inline">\(H\)</span></td><td style="text-align: center;"><code>\theta</code></td><td style="text-align: center;"><span class="math inline">\(\theta\)</span></td><td style="text-align: center;"><code>\Theta</code></td><td style="text-align: center;"><span class="math inline">\(\Theta\)</span></td></tr><tr class="odd"><td style="text-align: center;"><code>\iota</code></td><td style="text-align: center;"><span class="math inline">\(\iota\)</span></td><td style="text-align: center;"><code>I</code></td><td style="text-align: center;"><span class="math inline">\(I\)</span></td><td style="text-align: center;"><code>\kappa</code></td><td style="text-align: center;"><span class="math inline">\(\kappa\)</span></td><td style="text-align: center;"><code>K</code></td><td style="text-align: center;"><span class="math inline">\(K\)</span></td></tr><tr class="even"><td style="text-align: center;"><code>\lambda</code></td><td style="text-align: center;"><span class="math inline">\(\lambda\)</span></td><td style="text-align: center;"><code>\Lambda</code></td><td style="text-align: center;"><span class="math inline">\(\Lambda\)</span></td><td style="text-align: center;"><code>\mu</code></td><td style="text-align: center;"><span class="math inline">\(\mu\)</span></td><td style="text-align: center;"><code>M</code></td><td style="text-align: center;"><span class="math inline">\(M\)</span></td></tr><tr class="odd"><td style="text-align: center;"><code>\nu</code></td><td style="text-align: center;"><span class="math inline">\(\nu\)</span></td><td style="text-align: center;"><code>N</code></td><td style="text-align: center;"><span class="math inline">\(N\)</span></td><td style="text-align: center;"><code>\xi</code></td><td style="text-align: center;"><span class="math inline">\(\xi\)</span></td><td style="text-align: center;"><code>\Xi</code></td><td style="text-align: center;"><span class="math inline">\(\Xi\)</span></td></tr><tr class="even"><td style="text-align: center;"><code>o</code></td><td style="text-align: center;"><span class="math inline">\(o\)</span></td><td style="text-align: center;"><code>O</code></td><td style="text-align: center;"><span class="math inline">\(O\)</span></td><td style="text-align: center;"><code>\pi</code></td><td style="text-align: center;"><span class="math inline">\(\pi\)</span></td><td style="text-align: center;"><code>\Pi</code></td><td style="text-align: center;"><span class="math inline">\(\Pi\)</span></td></tr><tr class="odd"><td style="text-align: center;"><code>\rho</code></td><td style="text-align: center;"><span class="math inline">\(\rho\)</span></td><td style="text-align: center;"><code>P</code></td><td style="text-align: center;"><span class="math inline">\(P\)</span></td><td style="text-align: center;"><code>\sigma</code></td><td style="text-align: center;"><span class="math inline">\(\sigma\)</span></td><td style="text-align: center;"><code>\Sigma</code></td><td style="text-align: center;"><span class="math inline">\(\Sigma\)</span></td></tr><tr class="even"><td style="text-align: center;"><code>\tau</code></td><td style="text-align: center;"><span class="math inline">\(\tau\)</span></td><td style="text-align: center;"><code>T</code></td><td style="text-align: center;"><span class="math inline">\(T\)</span></td><td style="text-align: center;"><code>\upsilon</code></td><td style="text-align: center;"><span class="math inline">\(\upsilon\)</span></td><td style="text-align: center;"><code>\Upsilon</code></td><td style="text-align: center;"><span class="math inline">\(\Upsilon\)</span></td></tr><tr class="odd"><td style="text-align: center;"><code>\phi</code></td><td style="text-align: center;"><span class="math inline">\(\phi\)</span></td><td style="text-align: center;"><code>\Phi</code></td><td style="text-align: center;"><span class="math inline">\(\Phi\)</span></td><td style="text-align: center;"><code>\chi</code></td><td style="text-align: center;"><span class="math inline">\(\chi\)</span></td><td style="text-align: center;"><code>X</code></td><td style="text-align: center;"><span class="math inline">\(X\)</span></td></tr><tr class="even"><td style="text-align: center;"><code>\psi</code></td><td style="text-align: center;"><span class="math inline">\(\psi\)</span></td><td style="text-align: center;"><code>\Psi</code></td><td style="text-align: center;"><span class="math inline">\(\Psi\)</span></td><td style="text-align: center;"><code>\omega</code></td><td style="text-align: center;"><span class="math inline">\(\omega\)</span></td><td style="text-align: center;"><code>\Omega</code></td><td style="text-align: center;"><span class="math inline">\(\Omega\)</span></td></tr></tbody></table><p><strong>部分字母有变量专用形式，以 <code>\var-</code>开头。</strong></p><table><thead><tr class="header"><th style="text-align: center;">小写形式</th><th style="text-align: center;">大写形式</th><th style="text-align: center;">变量形式</th><th style="text-align: center;">显示</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>\epsilon</code></td><td style="text-align: center;"><code>E</code></td><td style="text-align: center;"><code>\varepsilon</code></td><td style="text-align: center;"><span class="math inline">\(\epsilon\mid E \mid \varepsilon\)</span></td></tr><tr class="even"><td style="text-align: center;"><code>\theta</code></td><td style="text-align: center;"><code>\Theta</code></td><td style="text-align: center;"><code>\vartheta</code></td><td style="text-align: center;"><span class="math inline">\(\theta \mid\Theta \mid \vartheta\)</span></td></tr><tr class="odd"><td style="text-align: center;"><code>\rho</code></td><td style="text-align: center;"><code>P</code></td><td style="text-align: center;"><code>\varrho</code></td><td style="text-align: center;"><span class="math inline">\(\rho \mid P\mid \varrho\)</span></td></tr><tr class="even"><td style="text-align: center;"><code>\sigma</code></td><td style="text-align: center;"><code>\Sigma</code></td><td style="text-align: center;"><code>\varsigma</code></td><td style="text-align: center;"><span class="math inline">\(\sigma \mid\Sigma \mid \varsigma\)</span></td></tr><tr class="odd"><td style="text-align: center;"><code>\phi</code></td><td style="text-align: center;"><code>\Phi</code></td><td style="text-align: center;"><code>\varphi</code></td><td style="text-align: center;"><span class="math inline">\(\phi \mid\Phi \mid \varphi\)</span></td></tr></tbody></table><h2 id="如何输入其它特殊字符">12．如何输入其它特殊字符</h2><h3 id="关系运算符">(1)．关系运算符</h3><table><thead><tr class="header"><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>\pm</code></td><td style="text-align: center;"><span class="math inline">\(\pm\)</span></td><td style="text-align: center;"><code>\times</code></td><td style="text-align: center;"><span class="math inline">\(\times\)</span></td><td style="text-align: center;"><code>\div</code></td><td style="text-align: center;"><span class="math inline">\(\div\)</span></td><td style="text-align: center;"><code>\mid</code></td><td style="text-align: center;"><span class="math inline">\(\mid\)</span></td></tr><tr class="even"><td style="text-align: center;"><code>\nmid</code></td><td style="text-align: center;"><span class="math inline">\(\nmid\)</span></td><td style="text-align: center;"><code>\cdot</code></td><td style="text-align: center;"><span class="math inline">\(\cdot\)</span></td><td style="text-align: center;"><code>\circ</code></td><td style="text-align: center;"><span class="math inline">\(\circ\)</span></td><td style="text-align: center;"><code>\ast</code></td><td style="text-align: center;"><span class="math inline">\(\ast\)</span></td></tr><tr class="odd"><td style="text-align: center;"><code>\bigodot</code></td><td style="text-align: center;"><span class="math inline">\(\bigodot\)</span></td><td style="text-align: center;"><code>\bigotimes</code></td><td style="text-align: center;"><span class="math inline">\(\bigotimes\)</span></td><td style="text-align: center;"><code>\bigoplus</code></td><td style="text-align: center;"><span class="math inline">\(\bigoplus\)</span></td><td style="text-align: center;"><code>\leq</code></td><td style="text-align: center;"><span class="math inline">\(\leq\)</span></td></tr><tr class="even"><td style="text-align: center;"><code>\geq</code></td><td style="text-align: center;"><span class="math inline">\(\geq\)</span></td><td style="text-align: center;"><code>\neq</code></td><td style="text-align: center;"><span class="math inline">\(\neq\)</span></td><td style="text-align: center;"><code>\approx</code></td><td style="text-align: center;"><span class="math inline">\(\approx\)</span></td><td style="text-align: center;"><code>\equiv</code></td><td style="text-align: center;"><span class="math inline">\(\equiv\)</span></td></tr><tr class="odd"><td style="text-align: center;"><code>\sum</code></td><td style="text-align: center;"><span class="math inline">\(\sum\)</span></td><td style="text-align: center;"><code>\prod</code></td><td style="text-align: center;"><span class="math inline">\(\prod\)</span></td><td style="text-align: center;"><code>\coprod</code></td><td style="text-align: center;"><span class="math inline">\(\coprod\)</span></td><td style="text-align: center;"><code>\backslash</code></td><td style="text-align: center;"><span class="math inline">\(\backslash\)</span></td></tr></tbody></table><h3 id="集合运算符">(2)．集合运算符</h3><table><thead><tr class="header"><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>\emptyset</code></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><code>\in</code></td><td style="text-align: center;"><span class="math inline">\(\in\)</span></td><td style="text-align: center;"><code>\notin</code></td><td style="text-align: center;"><span class="math inline">\(\notin\)</span></td></tr><tr class="even"><td style="text-align: center;"><code>\subset</code></td><td style="text-align: center;"><span class="math inline">\(\subset\)</span></td><td style="text-align: center;"><code>\supset</code></td><td style="text-align: center;"><span class="math inline">\(\supset\)</span></td><td style="text-align: center;"><code>\subseteq</code></td><td style="text-align: center;"><span class="math inline">\(\subseteq\)</span></td></tr><tr class="odd"><td style="text-align: center;"><code>\supseteq</code></td><td style="text-align: center;"><span class="math inline">\(\supseteq\)</span></td><td style="text-align: center;"><code>\cap</code></td><td style="text-align: center;"><span class="math inline">\(\cap\)</span></td><td style="text-align: center;"><code>\cup</code></td><td style="text-align: center;"><span class="math inline">\(\cup\)</span></td></tr><tr class="even"><td style="text-align: center;"><code>\vee</code></td><td style="text-align: center;"><span class="math inline">\(\vee\)</span></td><td style="text-align: center;"><code>\wedge</code></td><td style="text-align: center;"><span class="math inline">\(\wedge\)</span></td><td style="text-align: center;"><code>\uplus</code></td><td style="text-align: center;"><span class="math inline">\(\uplus\)</span></td></tr><tr class="odd"><td style="text-align: center;"><code>\top</code></td><td style="text-align: center;"><span class="math inline">\(\top\)</span></td><td style="text-align: center;"><code>\bot</code></td><td style="text-align: center;"><span class="math inline">\(\bot\)</span></td><td style="text-align: center;"><code>\complement</code></td><td style="text-align: center;"><span class="math inline">\(\complement\)</span></td></tr></tbody></table><h3 id="对数运算符">(3)．对数运算符</h3><table><thead><tr class="header"><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>\log</code></td><td style="text-align: center;"><span class="math inline">\(\log\)</span></td><td style="text-align: center;"><code>\lg</code></td><td style="text-align: center;"><span class="math inline">\(\lg\)</span></td><td style="text-align: center;"><code>\ln</code></td><td style="text-align: center;"><span class="math inline">\(\ln\)</span></td></tr></tbody></table><h3 id="三角运算符">(4)．三角运算符</h3><table><thead><tr class="header"><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>\backsim</code></td><td style="text-align: center;"><span class="math inline">\(\backsim\)</span></td><td style="text-align: center;"><code>\cong</code></td><td style="text-align: center;"><span class="math inline">\(\cong\)</span></td><td style="text-align: center;"><code>\angle A</code></td><td style="text-align: center;"><span class="math inline">\(\angleA\)</span></td></tr><tr class="even"><td style="text-align: center;"><code>\sin</code></td><td style="text-align: center;"><span class="math inline">\(\sin\)</span></td><td style="text-align: center;"><code>\cos</code></td><td style="text-align: center;"><span class="math inline">\(\cos\)</span></td><td style="text-align: center;"><code>\tan</code></td><td style="text-align: center;"><span class="math inline">\(\tan\)</span></td></tr><tr class="odd"><td style="text-align: center;"><code>\csc</code></td><td style="text-align: center;"><span class="math inline">\(\csc\)</span></td><td style="text-align: center;"><code>\sec</code></td><td style="text-align: center;"><span class="math inline">\(\sec\)</span></td><td style="text-align: center;"><code>\cot</code></td><td style="text-align: center;"><span class="math inline">\(\cot\)</span></td></tr></tbody></table><h3 id="微积分运算符">(5)．微积分运算符</h3><table><thead><tr class="header"><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>\int</code></td><td style="text-align: center;"><span class="math inline">\(\int\)</span></td><td style="text-align: center;"><code>\iint</code></td><td style="text-align: center;"><span class="math inline">\(\iint\)</span></td><td style="text-align: center;"><code>\iiint</code></td><td style="text-align: center;"><span class="math inline">\(\iiint\)</span></td></tr><tr class="even"><td style="text-align: center;"><code>\partial</code></td><td style="text-align: center;"><span class="math inline">\(\partial\)</span></td><td style="text-align: center;"><code>\oint</code></td><td style="text-align: center;"><span class="math inline">\(\oint\)</span></td><td style="text-align: center;"><code>\prime</code></td><td style="text-align: center;"><span class="math inline">\(\prime\)</span></td></tr><tr class="odd"><td style="text-align: center;"><code>\lim</code></td><td style="text-align: center;"><span class="math inline">\(\lim\)</span></td><td style="text-align: center;"><code>\infty</code></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><code>\nabla</code></td><td style="text-align: center;"><span class="math inline">\(\nabla\)</span></td></tr></tbody></table><h3 id="逻辑运算符">(6)．逻辑运算符</h3><table><thead><tr class="header"><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>\because</code></td><td style="text-align: center;"><span class="math inline">\(\because\)</span></td><td style="text-align: center;"><code>\therefore</code></td><td style="text-align: center;"><span class="math inline">\(\therefore\)</span></td><td style="text-align: center;"><code>\neg</code></td><td style="text-align: center;"><span class="math inline">\(\neg\)</span></td></tr><tr class="even"><td style="text-align: center;"><code>\forall</code></td><td style="text-align: center;"><span class="math inline">\(\forall\)</span></td><td style="text-align: center;"><code>\exists</code></td><td style="text-align: center;"><span class="math inline">\(\exists\)</span></td><td style="text-align: center;"><code>\not\subset</code></td><td style="text-align: center;"><span class="math inline">\(\not\subset\)</span></td></tr><tr class="odd"><td style="text-align: center;"><code>\not&lt;</code></td><td style="text-align: center;"><span class="math inline">\(\not&lt;\)</span></td><td style="text-align: center;"><code>\not&gt;</code></td><td style="text-align: center;"><span class="math inline">\(\not&gt;\)</span></td><td style="text-align: center;"><code>\not=</code></td><td style="text-align: center;"><span class="math inline">\(\not=\)</span></td></tr></tbody></table><h3 id="戴帽符号">(7)．戴帽符号</h3><table style="width:100%;"><thead><tr class="header"><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>\hat&#123;xy&#125;</code></td><td style="text-align: center;"><span class="math inline">\(\hat{xy}\)</span></td><td style="text-align: center;"><code>\widehat&#123;xyz&#125;</code></td><td style="text-align: center;"><span class="math inline">\(\widehat{xyz}\)</span></td><td style="text-align: center;"><code>\bar&#123;y&#125;</code></td><td style="text-align: center;"><span class="math inline">\(\bar{y}\)</span></td></tr><tr class="even"><td style="text-align: center;"><code>\tilde&#123;xy&#125;</code></td><td style="text-align: center;"><span class="math inline">\(\tilde{xy}\)</span></td><td style="text-align: center;"><code>\widetilde&#123;xyz&#125;</code></td><td style="text-align: center;"><span class="math inline">\(\widetilde{xyz}\)</span></td><td style="text-align: center;"><code>\acute&#123;y&#125;</code></td><td style="text-align: center;"><span class="math inline">\(\acute{y}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><code>\breve&#123;y&#125;</code></td><td style="text-align: center;"><span class="math inline">\(\breve{y}\)</span></td><td style="text-align: center;"><code>\check&#123;y&#125;</code></td><td style="text-align: center;"><span class="math inline">\(\check{y}\)</span></td><td style="text-align: center;"><code>\grave&#123;y&#125;</code></td><td style="text-align: center;"><span class="math inline">\(\grave{y}\)</span></td></tr><tr class="even"><td style="text-align: center;"><code>\dot&#123;x&#125;</code></td><td style="text-align: center;"><span class="math inline">\(\dot{x}\)</span></td><td style="text-align: center;"><code>\ddot&#123;x&#125;</code></td><td style="text-align: center;"><span class="math inline">\(\ddot{x}\)</span></td><td style="text-align: center;"><code>\dddot&#123;x&#125;</code></td><td style="text-align: center;"><span class="math inline">\(\ddot{x}\)</span></td></tr></tbody></table><p>若需要在特定文字顶部，可使用<code>\overset&#123;顶部内容&#125;&#123;正常内容&#125;</code> 和<code>\underset&#123;底部内容&#125;&#123;正常内容&#125;</code> 命令。</p><ul><li>例子：</li></ul><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">$$ <span class="hljs-string">\verb+\overset&#123;above&#125;&#123;level&#125;+</span> <span class="hljs-string">\qquad</span> <span class="hljs-string">\overset&#123;xx&#125;&#123;ABC&#125;</span> <span class="hljs-string">\;\;</span> <span class="hljs-string">\mid</span> <span class="hljs-string">\quad</span> <span class="hljs-string">\overset&#123;x^2&#125;&#123;\longmapsto&#125;\</span> <span class="hljs-string">\,</span> <span class="hljs-string">\mid</span> <span class="hljs-string">\quad</span> <span class="hljs-string">\overset&#123;\bullet\circ\circ\bullet&#125;&#123;T&#125;</span> $$<br></code></pre></td></tr></table></figure><ul><li>显示：</li></ul><p><span class="math display">\[ \verb+\overset{above}{level}+ \qquad\overset{xx}{ABC} \;\; \mid \quad \overset{x^2}{\longmapsto}\ \, \mid\quad \overset{\bullet\circ\circ\bullet}{T} \]</span></p><ul><li>例子：</li></ul><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">$$ <span class="hljs-string">\verb+\underset&#123;below&#125;&#123;level&#125;+</span> <span class="hljs-string">\qquad</span> <span class="hljs-string">\underset&#123;xx&#125;&#123;ABC&#125;</span> <span class="hljs-string">\;\;</span> <span class="hljs-string">\mid</span> <span class="hljs-string">\quad</span> <span class="hljs-string">\underset&#123;x^2&#125;&#123;\longmapsto&#125;\</span> <span class="hljs-string">\,</span> <span class="hljs-string">\mid</span> <span class="hljs-string">\quad</span> <span class="hljs-string">\underset&#123;\bullet\circ\circ\bullet&#125;&#123;T&#125;</span> $$<br></code></pre></td></tr></table></figure><ul><li>显示：</li></ul><p><span class="math display">\[ \verb+\underset{below}{level}+ \qquad\underset{xx}{ABC} \;\; \mid \quad \underset{x^2}{\longmapsto}\ \, \mid\quad \underset{\bullet\circ\circ\bullet}{T} \]</span></p><p>此命令可叠加嵌套使用，生成类似化学反应式的多重条件符号， 如<code>\overset&#123;H_2&#125;&#123;\underset&#123;1300℃&#125;&#123;\Longleftrightarrow&#125;&#125;</code>：<span class="math display">\[ \rm{SrO+V^{&#39;&#39;}_{Sr}\overset{H_2}{\underset{1300℃}{\Longleftrightarrow}}Sr^{\times}_{Sr}+2e^{&#39;}+\frac 12O_2(g)} \]</span> 和<code>\overset&#123;Surface/bulk&#125;&#123;\underset&#123;diffusion&#125;&#123;\longleftrightarrow&#125;&#125;</code>：<span class="math display">\[\rm{2OH^{\bullet}_{O(STN)}+2O^{\times}_{O(YSZ)} \;\overset{Surface/bulk}{\underset{diffusion}{\longleftrightarrow}} \;\;2OH^{\bullet}_{O(YSZ)}+2O^{\times}_{O(STN)}} \]</span></p><p>一般建议在书写化学方程式时声明 <code>\require&#123;AMDcd&#125;</code>语句，使用 MathJax 内置的交换图表功能，具体例子可<a href="#1如何输入一个交换图表">参见下文</a>。</p><h3 id="连线符号">(8)．连线符号</h3><p>其它可用的文字修饰符可参见官方文档 <a href="https://math.meta.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference#answer-13081">"Additionaldecorations"</a>。</p><table><thead><tr class="header"><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>\fbox&#123;a+b+c+d&#125;</code> <span style="display: block"><strong>高级框选需<a href="#5添加删除线">声明<code>enclose</code> 标签</a></strong></span></td><td style="text-align: center;"><span class="math inline">\(\fbox{a+b+c+d}\)</span></td></tr><tr class="even"><td style="text-align: center;"><code>\overleftarrow&#123;a+b+c+d&#125;</code></td><td style="text-align: center;"><span class="math inline">\(\overleftarrow{a+b+c+d}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><code>\overrightarrow&#123;a+b+c+d&#125;</code></td><td style="text-align: center;"><span class="math inline">\(\overrightarrow{a+b+c+d}\)</span></td></tr><tr class="even"><td style="text-align: center;"><code>\overleftrightarrow&#123;a+b+c+d&#125;</code></td><td style="text-align: center;"><span class="math inline">\(\overleftrightarrow{a+b+c+d}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><code>\underleftarrow&#123;a+b+c+d&#125;</code></td><td style="text-align: center;"><span class="math inline">\(\underleftarrow{a+b+c+d}\)</span></td></tr><tr class="even"><td style="text-align: center;"><code>\underrightarrow&#123;a+b+c+d&#125;</code></td><td style="text-align: center;"><span class="math inline">\(\underrightarrow{a+b+c+d}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><code>\underleftrightarrow&#123;a+b+c+d&#125;</code></td><td style="text-align: center;"><span class="math inline">\(\underleftrightarrow{a+b+c+d}\)</span></td></tr><tr class="even"><td style="text-align: center;"><code>\overline&#123;a+b+c+d&#125;</code></td><td style="text-align: center;"><span class="math inline">\(\overline{a+b+c+d}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><code>\underline&#123;a+b+c+d&#125;</code></td><td style="text-align: center;"><span class="math inline">\(\underline{a+b+c+d}\)</span></td></tr><tr class="even"><td style="text-align: center;"><code>\overbrace&#123;a+b+c+d&#125;^&#123;Sample&#125;</code></td><td style="text-align: center;"><span class="math inline">\(\overbrace{a+b+c+d}^{Sample}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><code>\underbrace&#123;a+b+c+d&#125;_&#123;Sample&#125;</code></td><td style="text-align: center;"><span class="math inline">\(\underbrace{a+b+c+d}_{Sample}\)</span></td></tr><tr class="even"><td style="text-align: center;"><code>\overbrace&#123;a+\underbrace&#123;b+c&#125;_&#123;1.0&#125;+d&#125;^&#123;2.0&#125;</code></td><td style="text-align: center;"><span class="math inline">\(\overbrace{a+\underbrace{b+c}_{1.0}+d}^{2.0}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><code>\underbrace&#123;a\cdot a\cdots a&#125;_&#123;b\text&#123; times&#125;&#125;</code></td><td style="text-align: center;"><span class="math inline">\(\underbrace{a\cdot a\cdots a}_{b\text{times}}\)</span></td></tr></tbody></table><h3 id="箭头符号">(9)．箭头符号</h3><ul><li>推荐使用符号：</li></ul><table style="width:100%;"><thead><tr class="header"><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>\to</code></td><td style="text-align: center;"><span class="math inline">\(\to\)</span></td><td style="text-align: center;"><code>\mapsto</code></td><td style="text-align: center;"><span class="math inline">\(\mapsto\)</span></td><td style="text-align: center;"><code>\underrightarrow&#123;1℃/min&#125;</code></td><td style="text-align: center;"><span class="math inline">\(\underrightarrow{1℃/min}\)</span></td></tr><tr class="even"><td style="text-align: center;"><code>\implies</code></td><td style="text-align: center;"><span class="math inline">\(\implies\)</span></td><td style="text-align: center;"><code>\iff</code></td><td style="text-align: center;"><span class="math inline">\(\iff\)</span></td><td style="text-align: center;"><code>\impliedby</code></td><td style="text-align: center;"><span class="math inline">\(\impliedby\)</span></td></tr></tbody></table><ul><li>其它可用符号：</li></ul><table><thead><tr class="header"><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>\uparrow</code></td><td style="text-align: center;"><span class="math inline">\(\uparrow\)</span></td><td style="text-align: center;"><code>\Uparrow</code></td><td style="text-align: center;"><span class="math inline">\(\Uparrow\)</span></td></tr><tr class="even"><td style="text-align: center;"><code>\downarrow</code></td><td style="text-align: center;"><span class="math inline">\(\downarrow\)</span></td><td style="text-align: center;"><code>\Downarrow</code></td><td style="text-align: center;"><span class="math inline">\(\Downarrow\)</span></td></tr><tr class="odd"><td style="text-align: center;"><code>\leftarrow</code></td><td style="text-align: center;"><span class="math inline">\(\leftarrow\)</span></td><td style="text-align: center;"><code>\Leftarrow</code></td><td style="text-align: center;"><span class="math inline">\(\Leftarrow\)</span></td></tr><tr class="even"><td style="text-align: center;"><code>\rightarrow</code></td><td style="text-align: center;"><span class="math inline">\(\rightarrow\)</span></td><td style="text-align: center;"><code>\Rightarrow</code></td><td style="text-align: center;"><span class="math inline">\(\Rightarrow\)</span></td></tr><tr class="odd"><td style="text-align: center;"><code>\leftrightarrow</code></td><td style="text-align: center;"><span class="math inline">\(\leftrightarrow\)</span></td><td style="text-align: center;"><code>\Leftrightarrow</code></td><td style="text-align: center;"><span class="math inline">\(\Leftrightarrow\)</span></td></tr><tr class="even"><td style="text-align: center;"><code>\longleftarrow</code></td><td style="text-align: center;"><span class="math inline">\(\longleftarrow\)</span></td><td style="text-align: center;"><code>\Longleftarrow</code></td><td style="text-align: center;"><span class="math inline">\(\Longleftarrow\)</span></td></tr><tr class="odd"><td style="text-align: center;"><code>\longrightarrow</code></td><td style="text-align: center;"><span class="math inline">\(\longrightarrow\)</span></td><td style="text-align: center;"><code>\Longrightarrow</code></td><td style="text-align: center;"><span class="math inline">\(\Longrightarrow\)</span></td></tr><tr class="even"><td style="text-align: center;"><code>\longleftrightarrow</code></td><td style="text-align: center;"><span class="math inline">\(\longleftrightarrow\)</span></td><td style="text-align: center;"><code>\Longleftrightarrow</code></td><td style="text-align: center;"><span class="math inline">\(\Longleftrightarrow\)</span></td></tr></tbody></table><h2 id="进行字体转换">13．进行字体转换</h2><p>若要对公式的某一部分字符进行字体转换，可以用<code>&#123;\字体 &#123;需转换的部分字符&#125;&#125;</code> 命令，其中 <code>\字体</code>部分可以参照下表选择合适的字体。一般情况下，公式默认为斜体字 <span class="math inline">\(italic\)</span> 。</p><p>示例中 <strong>全部大写</strong> 的字体仅大写可用。</p><table style="width:100%;"><thead><tr class="header"><th style="text-align: center;">输入</th><th style="text-align: center;">全字母可用</th><th style="text-align: center;">显示</th><th style="text-align: center;">输入</th><th style="text-align: center;">仅大写可用</th><th style="text-align: center;">显示</th><th style="text-align: center;"></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>\rm</code></td><td style="text-align: center;">罗马体</td><td style="text-align: center;"><span class="math inline">\(\rm{Sample}\)</span></td><td style="text-align: center;"><code>\mathcal</code></td><td style="text-align: center;"><strong>花体（数学符号等）</strong></td><td style="text-align: center;"><span class="math inline">\(\mathcal{SAMPLE}\)</span></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>\it</code></td><td style="text-align: center;">斜体</td><td style="text-align: center;"><span class="math inline">\(\it{Sample}\)</span></td><td style="text-align: center;"><code>\mathbb</code></td><td style="text-align: center;"><strong>黑板粗体（定义域等）</strong></td><td style="text-align: center;"><span class="math inline">\(\mathbb{SAMPLE}\)</span></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><code>\bf</code></td><td style="text-align: center;">粗体</td><td style="text-align: center;"><span class="math inline">\(\bf{Sample}\)</span></td><td style="text-align: center;"><code>\mit</code></td><td style="text-align: center;">数学斜体</td><td style="text-align: center;"><span class="math inline">\(none\)</span></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>\sf</code></td><td style="text-align: center;">等线体</td><td style="text-align: center;"><span class="math inline">\(\sf{Sample}\)</span></td><td style="text-align: center;"><code>\scr</code></td><td style="text-align: center;">手写体</td><td style="text-align: center;"><span class="math inline">\(none\)</span></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><code>\tt</code></td><td style="text-align: center;">打字机体</td><td style="text-align: center;"><span class="math inline">\(\tt{Sample}\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>\frak</code></td><td style="text-align: center;">旧德式字体</td><td style="text-align: center;"><span class="math inline">\(\frak{Sample}\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table><blockquote><p><code>\boldsymbol&#123;\alpha&#125;</code>用来表示向量或者矩阵的加粗斜体，如向量 <span class="math inline">\(\boldsymbol{\vec\alpha}\)</span>。</p></blockquote><p>转换字体十分常用，例如在积分中：</p><ul><li>例子：</li></ul><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\begin&#123;array&#125;&#123;cc&#125;</span><br>    <span class="hljs-string">\mathrm&#123;Bad&#125;</span> &amp; <span class="hljs-string">\mathrm&#123;Better&#125;</span> <span class="hljs-string">\\</span><br>    <span class="hljs-string">\hline</span> <span class="hljs-string">\\</span><br>    <span class="hljs-string">\int_0^1</span> x^<span class="hljs-number">2</span> dx &amp; <span class="hljs-string">\int_0^1</span> x^<span class="hljs-number">2</span> <span class="hljs-string">\,&#123;\rm</span> d&#125;x<br><span class="hljs-string">\end&#123;array&#125;</span><br></code></pre></td></tr></table></figure><ul><li>显示：</li></ul><p><span class="math display">\[\begin{array}{cc}    \mathrm{Bad} &amp; \mathrm{Better} \\    \hline \\    \int_0^1 x^2 dx &amp; \int_0^1 x^2 \,{\rm d}x\end{array}\]</span></p><p>注意比较两个式子间 <span class="math inline">\(dx\)</span> 与 <span class="math inline">\({\rm d} x\)</span> 的不同。 使用<code>\operatorname</code> 命令也可以达到相同的效果，详见“<a href="#1定义新的运算符-operatorname">定义新的运算符</a>”。</p><h2 id="大括号和行标的使用">14．大括号和行标的使用</h2><p>在 <code>\left</code> 和 <code>\right</code>之后加上要使用的括号来创建自动匹配高度的圆括号 <code>(</code><code>)</code>，方括号 <code>[</code> <code>]</code> 和花括号<code>\&#123;</code> <code>\&#125;</code>。 在每个公式末尾前使用<code>\tag &#123;行标&#125;</code> 来实现行标。</p><ul><li>例子：</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br>f<span class="hljs-keyword">\left</span>(<br>   <span class="hljs-keyword">\left</span>[ <br>     <span class="hljs-keyword">\frac</span>&#123;<br>       1+<span class="hljs-keyword">\left</span><span class="hljs-keyword">\&#123;</span>x,y<span class="hljs-keyword">\right</span><span class="hljs-keyword">\&#125;</span><br>     &#125;&#123;<br>       <span class="hljs-keyword">\left</span>(<br>          <span class="hljs-keyword">\frac</span> xy + <span class="hljs-keyword">\frac</span> yx<br>       <span class="hljs-keyword">\right</span>)<br>       (u+1)<br>     &#125;+a<br>   <span class="hljs-keyword">\right</span>]<span class="hljs-built_in">^</span>&#123;3/2&#125;<br><span class="hljs-keyword">\right</span>)<br><span class="hljs-keyword">\tag</span> &#123;行标&#125;<br><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br></code></pre></td></tr></table></figure><ul><li>显示： <span class="math display">\[f\left(\left[   \frac{     1+\left\{x,y\right\}   }{     \left(        \frac xy + \frac yx     \right)     (u+1)   }+a\right]^{3/2}\right)\tag {行标}\]</span></li></ul><p>如果你需要在不同的行显示对应括号，可以在每一行对应处使用<code>\left.</code> 或 <code>\right.</code> 来放一个“不存在的括号”。</p><ul><li>例子：</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br><span class="hljs-keyword">\begin</span>&#123;align*&#125;<br>    a=<span class="hljs-built_in">&amp;</span><span class="hljs-keyword">\left</span>(1+2+3+ <span class="hljs-keyword">\cdots</span> <span class="hljs-keyword">\right</span>. <span class="hljs-keyword">\\</span><br>      <span class="hljs-built_in">&amp;</span><span class="hljs-keyword">\cdots</span>+<span class="hljs-keyword">\left</span>. <span class="hljs-keyword">\infty</span>-2+<span class="hljs-keyword">\infty</span>-1+<span class="hljs-keyword">\infty</span><span class="hljs-keyword">\right</span>)<br><span class="hljs-keyword">\end</span>&#123;align*&#125;<br><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br></code></pre></td></tr></table></figure><ul><li>显示： <span class="math display">\[\begin{align*}  a=&amp;\left(1+2+3+ \cdots \right. \\    &amp;\cdots+\left. \infty-2+\infty-1+\infty\right)\end{align*}\]</span></li></ul><p>如果你需要将大括号里面显示的分隔符也变大，可以使用<code>\middle</code> 命令，此处分别使用单竖线 <code>|</code> 和双竖线<code>\\|</code> 。</p><ul><li>例子：</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br><span class="hljs-keyword">\left</span><span class="hljs-keyword">\langle</span>  <br>    q <span class="hljs-keyword">\;</span> <span class="hljs-keyword">\middle</span>|<br>        <span class="hljs-keyword">\frac</span>&#123;<span class="hljs-keyword">\frac</span> xy&#125;&#123;<span class="hljs-keyword">\frac</span> uv&#125;<br>    <span class="hljs-keyword">\middle</span><span class="hljs-keyword">\|</span> p <br><span class="hljs-keyword">\right</span><span class="hljs-keyword">\rangle</span><br><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br></code></pre></td></tr></table></figure><ul><li>显示： <span class="math display">\[\left\langle    q \; \middle|      \frac{\frac xy}{\frac uv}  \middle\| p\right\rangle\]</span></li></ul><h2 id="其它命令">15．其它命令</h2><h3 id="添加注释文字">(1)．添加注释文字 </h3><p>在 <code>\text &#123;文字&#125;</code> 中仍可以使用 <code>$公式$</code>插入其它公式。</p><ul><li>例子：</li></ul><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span> f(n)= \begin&#123;cases&#125; n/<span class="hljs-number">2</span>, &amp; \text &#123;<span class="hljs-keyword">if</span> <span class="hljs-symbol">$</span>n<span class="hljs-symbol">$</span> is even&#125; \\ <span class="hljs-number">3</span>n+<span class="hljs-number">1</span>, &amp; \text&#123;<span class="hljs-keyword">if</span> <span class="hljs-symbol">$</span>n<span class="hljs-symbol">$</span> is odd&#125; \end&#123;cases&#125; <span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><ul><li>显示： <span class="math display">\[ f(n)= \begin{cases} n/2, &amp;\text {if $n$ is even} \\ 3n+1, &amp; \text{if $n$ is odd} \end{cases}\]</span></li></ul><h3 id="在字符间加入空格">(2)．在字符间加入空格</h3><p>有四种宽度的空格可以使用：<code>\,</code>、<code>\;</code>、<code>\quad</code> 和<code>\qquad</code>，灵活使用 <code>\text&#123;n个空格&#125;</code>也可以在任意位置实现空格。 同时存在一种负空格 <code>\!</code>用来减小字符间距，一般在物理单位中使用。</p><ul><li>例子：</li></ul><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\begin&#123;array&#125;&#123;c|c&#125;</span><br>    <span class="hljs-string">\text&#123;Spaces&#125;</span> &amp; <span class="hljs-string">\text&#123;Negative</span> Space <span class="hljs-keyword">in</span> Units&#125; <span class="hljs-string">\\</span><br>    <span class="hljs-string">\hline</span> <span class="hljs-string">\\</span><br>    <span class="hljs-string">\overbrace&#123;a</span> <span class="hljs-string">\!</span> b&#125;^&#123;<span class="hljs-string">\text&#123;\!&#125;&#125;</span> <span class="hljs-string">\mid</span> <span class="hljs-string">\underbrace&#123;ab&#125;_&#123;\rm&#123;default&#125;&#125;</span> <span class="hljs-string">\mid</span> <span class="hljs-string">\overbrace&#123;a</span> <span class="hljs-string">\,</span> b&#125;^&#123;<span class="hljs-string">\text&#123;\,&#125;&#125;</span> <span class="hljs-string">\mid</span> <span class="hljs-string">\underbrace&#123;a</span> <span class="hljs-string">\;</span> b&#125;_&#123;<span class="hljs-string">\text&#123;\;&#125;&#125;</span> <span class="hljs-string">\mid</span> <span class="hljs-string">\overbrace&#123;a</span> <span class="hljs-string">\quad</span> b&#125;^&#123;<span class="hljs-string">\text&#123;\quad&#125;&#125;</span> <span class="hljs-string">\mid</span> <span class="hljs-string">\underbrace&#123;a</span> <span class="hljs-string">\qquad</span> b&#125;_&#123;<span class="hljs-string">\text&#123;\qquad&#125;&#125;</span> &amp; <span class="hljs-string">\mathrm&#123;N&#125;\!\cdot\!\mathrm&#123;m&#125;</span> <span class="hljs-string">\mid</span> <span class="hljs-string">\mathrm&#123;s&#125;\!\cdot\!\mathrm&#123;A&#125;</span> <span class="hljs-string">\mid</span> <span class="hljs-string">\mathrm&#123;kg&#125;\!\cdot\!\mathrm&#123;m&#125;^2</span> <span class="hljs-string">\\</span> <br><span class="hljs-string">\end&#123;array&#125;</span><br></code></pre></td></tr></table></figure><ul><li>显示： <span class="math display">\[\begin{array}{c|c}  \text{Spaces} &amp; \text{Negative Space in Units} \\  \hline \\  \overbrace{a \! b}^{\text{\!}} \mid \underbrace{ab}_{\rm{default}}\mid \overbrace{a \, b}^{\text{\,}} \mid \underbrace{a \; b}_{\text{\;}}\mid \overbrace{a \quad b}^{\text{\quad}} \mid \underbrace{a \qquadb}_{\text{\qquad}} &amp; \mathrm{N}\!\cdot\!\mathrm{m} \mid\mathrm{s}\!\cdot\!\mathrm{A} \mid \mathrm{kg}\!\cdot\!\mathrm{m}^2 \\\end{array}\]</span></li></ul><p>一些常见的公式单位可表达如下：</p><ul><li>例子：</li></ul><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span> \mu_0=<span class="hljs-number">4</span>\<span class="hljs-built_in">pi</span>\times10^&#123;<span class="hljs-number">-7</span>&#125; \ \left.\mathrm&#123;\mathrm&#123;T&#125;\!\cdot\!\mathrm&#123;m&#125;&#125;\middle/\mathrm&#123;A&#125;\right. <span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span> <span class="hljs-number">180</span>^\circ=\<span class="hljs-built_in">pi</span> \ \mathrm&#123;rad&#125; <span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span> \mathrm&#123;N_A&#125; = <span class="hljs-number">6.022</span>\times10^&#123;<span class="hljs-number">23</span>&#125; \ \mathrm&#123;mol&#125;^&#123;<span class="hljs-number">-1</span>&#125; <span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><ul><li>显示： <span class="math display">\[ \mu_0=4\pi\times10^{-7} \\left.\mathrm{\mathrm{T}\!\cdot\!\mathrm{m}}\middle/\mathrm{A}\right.\]</span> <span class="math display">\[ 180^\circ=\pi \ \mathrm{rad}\]</span> <span class="math display">\[ \mathrm{N_A} =6.022\times10^{23} \ \mathrm{mol}^{-1} \]</span></li></ul><h3 id="更改文字颜色">(3)．更改文字颜色 </h3><p>使用 <code>\color&#123;颜色&#125;&#123;文字&#125;</code> 来更改特定的文字颜色。</p><table><thead><tr class="header"><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">black</td><td style="text-align: center;"><span class="math inline">\(\color{black}{text}\)</span></td><td style="text-align: center;">grey</td><td style="text-align: center;"><span class="math inline">\(\color{grey}{text}\)</span></td></tr><tr class="even"><td style="text-align: center;">silver</td><td style="text-align: center;"><span class="math inline">\(\color{silver}{text}\)</span></td><td style="text-align: center;">white</td><td style="text-align: center;"><span class="math inline">\(\color{white}{text}\)</span></td></tr><tr class="odd"><td style="text-align: center;">maroon</td><td style="text-align: center;"><span class="math inline">\(\color{maroon}{text}\)</span></td><td style="text-align: center;">red</td><td style="text-align: center;"><span class="math inline">\(\color{red}{text}\)</span></td></tr><tr class="even"><td style="text-align: center;">yellow</td><td style="text-align: center;"><span class="math inline">\(\color{yellow}{text}\)</span></td><td style="text-align: center;">lime</td><td style="text-align: center;"><span class="math inline">\(\color{lime}{text}\)</span></td></tr><tr class="odd"><td style="text-align: center;">olive</td><td style="text-align: center;"><span class="math inline">\(\color{olive}{text}\)</span></td><td style="text-align: center;">green</td><td style="text-align: center;"><span class="math inline">\(\color{green}{text}\)</span></td></tr><tr class="even"><td style="text-align: center;">teal</td><td style="text-align: center;"><span class="math inline">\(\color{teal}{text}\)</span></td><td style="text-align: center;">auqa</td><td style="text-align: center;"><span class="math inline">\(\color{auqa}{text}\)</span></td></tr><tr class="odd"><td style="text-align: center;">blue</td><td style="text-align: center;"><span class="math inline">\(\color{blue}{text}\)</span></td><td style="text-align: center;">navy</td><td style="text-align: center;"><span class="math inline">\(\color{navy}{text}\)</span></td></tr><tr class="even"><td style="text-align: center;">purple</td><td style="text-align: center;"><span class="math inline">\(\color{purple}{text}\)</span></td><td style="text-align: center;">fuchsia</td><td style="text-align: center;"><span class="math inline">\(\color{fuchsia}{text}\)</span></td></tr></tbody></table><h3 id="添加删除线">(4)．添加删除线</h3><h1 id="二矩阵使用参考">二、矩阵使用参考</h1><h2 id="如何输入无框矩阵">1．如何输入无框矩阵</h2><p>在开头使用 <code>\begin&#123;matrix&#125;</code>，在结尾使用<code>\end&#123;matrix&#125;</code>，在中间插入矩阵元素，每个元素之间插入<code>&amp;</code> ，并在每行结尾处使用 <code>\\</code> 。使用矩阵时必须声明 <code>$</code> 或 <code>$$</code> 符号。</p><ul><li>例子：</li></ul><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">$$<br><span class="hljs-string">\begin&#123;matrix&#125;</span><br>    <span class="hljs-number">1</span> &amp; x &amp; x^<span class="hljs-number">2</span> <span class="hljs-string">\\</span><br>    <span class="hljs-number">1</span> &amp; y &amp; y^<span class="hljs-number">2</span> <span class="hljs-string">\\</span><br>    <span class="hljs-number">1</span> &amp; z &amp; z^<span class="hljs-number">2</span> <span class="hljs-string">\\</span><br><span class="hljs-string">\end&#123;matrix&#125;</span><br>$$<br></code></pre></td></tr></table></figure><ul><li>显示：</li></ul><p><span class="math display">\[\begin{matrix}    1 &amp; x &amp; x^2 \\    1 &amp; y &amp; y^2 \\    1 &amp; z &amp; z^2 \\\end{matrix}\]</span></p><h2 id="如何输入边框矩阵">2．如何输入边框矩阵</h2><p>在开头将 <code>matrix</code> 替换为 <code>pmatrix</code><code>bmatrix</code> <code>Bmatrix</code> <code>vmatrix</code><code>Vmatrix</code> 。</p><ul><li>例子：</li></ul><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livescript">$ <span class="hljs-string">\begin&#123;matrix&#125;</span> <span class="hljs-number">1</span> &amp; <span class="hljs-number">2</span> <span class="hljs-string">\\</span> <span class="hljs-number">3</span> &amp; <span class="hljs-number">4</span> <span class="hljs-string">\\</span> <span class="hljs-string">\end&#123;matrix&#125;</span> $<br>$ <span class="hljs-string">\begin&#123;pmatrix&#125;</span> <span class="hljs-number">1</span> &amp; <span class="hljs-number">2</span> <span class="hljs-string">\\</span> <span class="hljs-number">3</span> &amp; <span class="hljs-number">4</span> <span class="hljs-string">\\</span> <span class="hljs-string">\end&#123;pmatrix&#125;</span> $<br>$ <span class="hljs-string">\begin&#123;bmatrix&#125;</span> <span class="hljs-number">1</span> &amp; <span class="hljs-number">2</span> <span class="hljs-string">\\</span> <span class="hljs-number">3</span> &amp; <span class="hljs-number">4</span> <span class="hljs-string">\\</span> <span class="hljs-string">\end&#123;bmatrix&#125;</span> $<br>$ <span class="hljs-string">\begin&#123;Bmatrix&#125;</span> <span class="hljs-number">1</span> &amp; <span class="hljs-number">2</span> <span class="hljs-string">\\</span> <span class="hljs-number">3</span> &amp; <span class="hljs-number">4</span> <span class="hljs-string">\\</span> <span class="hljs-string">\end&#123;Bmatrix&#125;</span> $<br>$ <span class="hljs-string">\begin&#123;vmatrix&#125;</span> <span class="hljs-number">1</span> &amp; <span class="hljs-number">2</span> <span class="hljs-string">\\</span> <span class="hljs-number">3</span> &amp; <span class="hljs-number">4</span> <span class="hljs-string">\\</span> <span class="hljs-string">\end&#123;vmatrix&#125;</span> $<br>$ <span class="hljs-string">\begin&#123;Vmatrix&#125;</span> <span class="hljs-number">1</span> &amp; <span class="hljs-number">2</span> <span class="hljs-string">\\</span> <span class="hljs-number">3</span> &amp; <span class="hljs-number">4</span> <span class="hljs-string">\\</span> <span class="hljs-string">\end&#123;Vmatrix&#125;</span> $<br></code></pre></td></tr></table></figure><ul><li>显示：</li></ul><table style="width:100%;"><thead><tr class="header"><th style="text-align: center;">matrix</th><th style="text-align: center;">pmatrix</th><th style="text-align: center;">bmatrix</th><th style="text-align: center;">Bmatrix</th><th style="text-align: center;">vmatrix</th><th style="text-align: center;">Vmatrix</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\begin{matrix} 1 &amp; 2 \\ 3 &amp; 4 \\\end{matrix}\)</span></td><td style="text-align: center;"><span class="math inline">\(\begin{pmatrix} 1 &amp; 2 \\ 3 &amp; 4\\\end{pmatrix}\)</span></td><td style="text-align: center;"><span class="math inline">\(\begin{bmatrix} 1 &amp; 2 \\ 3 &amp; 4 \\\end{bmatrix}\)</span></td><td style="text-align: center;"><span class="math inline">\(\begin{Bmatrix} 1 &amp; 2 \\ 3 &amp; 4 \\\end{Bmatrix}\)</span></td><td style="text-align: center;"><span class="math inline">\(\begin{vmatrix} 1 &amp; 2 \\ 3 &amp; 4 \\\end{vmatrix}\)</span></td><td style="text-align: center;"><span class="math inline">\(\begin{Vmatrix} 1 &amp; 2 \\ 3 &amp; 4 \\\end{Vmatrix}\)</span></td></tr></tbody></table><h2 id="如何输入带省略符号的矩阵">3．如何输入带省略符号的矩阵</h2><p>使用 <code>\cdots</code> <span class="math inline">\(\cdots\)</span>, <code>\ddots</code> <span class="math inline">\(\ddots\)</span> ,<code>\vdots</code> <span class="math inline">\(\vdots\)</span>来输入省略符号。</p><ul><li>例子：</li></ul><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livescript">$$<br><span class="hljs-string">\begin&#123;pmatrix&#125;</span><br>    <span class="hljs-number">1</span> &amp; a_1 &amp; a_1^<span class="hljs-number">2</span> &amp; <span class="hljs-string">\cdots</span> &amp; a_1^n <span class="hljs-string">\\</span><br>    <span class="hljs-number">1</span> &amp; a_2 &amp; a_2^<span class="hljs-number">2</span> &amp; <span class="hljs-string">\cdots</span> &amp; a_2^n <span class="hljs-string">\\</span><br>    <span class="hljs-string">\vdots</span> &amp; <span class="hljs-string">\vdots</span> &amp; <span class="hljs-string">\vdots</span> &amp; <span class="hljs-string">\ddots</span> &amp; <span class="hljs-string">\vdots</span> <span class="hljs-string">\\</span><br>    <span class="hljs-number">1</span> &amp; a_m &amp; a_m^<span class="hljs-number">2</span> &amp; <span class="hljs-string">\cdots</span> &amp; a_m^n <span class="hljs-string">\\</span><br><span class="hljs-string">\end&#123;pmatrix&#125;</span><br>$$<br></code></pre></td></tr></table></figure><ul><li>显示：</li></ul><p><span class="math display">\[\begin{pmatrix}    1 &amp; a_1 &amp; a_1^2 &amp; \cdots &amp; a_1^n \\    1 &amp; a_2 &amp; a_2^2 &amp; \cdots &amp; a_2^n \\    \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\    1 &amp; a_m &amp; a_m^2 &amp; \cdots &amp; a_m^n \\\end{pmatrix}\]</span></p><h2 id="如何输入带分割符号的矩阵">4．如何输入带分割符号的矩阵</h2><p>详见"<a href="#五数组与表格使用参考">数组使用参考</a>"。</p><ul><li>例子：</li></ul><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livescript">$$<br><span class="hljs-string">\left[</span><br>    <span class="hljs-string">\begin&#123;array&#125;&#123;cc|c&#125;</span><br>        <span class="hljs-number">1</span> &amp; <span class="hljs-number">2</span> &amp; <span class="hljs-number">3</span> <span class="hljs-string">\\</span><br>        <span class="hljs-number">4</span> &amp; <span class="hljs-number">5</span> &amp; <span class="hljs-number">6</span> <span class="hljs-string">\\</span><br>    <span class="hljs-string">\end&#123;array&#125;</span><br><span class="hljs-string">\right]</span><br>$$<br></code></pre></td></tr></table></figure><ul><li>显示：</li></ul><p><span class="math display">\[\left[    \begin{array}{cc|c}        1 &amp; 2 &amp; 3 \\        4 &amp; 5 &amp; 6 \\    \end{array}\right]\]</span></p><p>其中 <code>cc|c</code>代表在一个三列矩阵中的第二和第三列之间插入分割线。</p><h2 id="输入行中矩阵">5．输入行中矩阵</h2><p>若想在一行内显示矩阵，使用<code>\bigl(\begin&#123;smallmatrix&#125; ... \end&#123;smallmatrix&#125;\bigr)</code>。</p><ul><li>例子：</li></ul><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal">这是一个行中矩阵的示例 <span class="hljs-variable">$\</span>bigl(\<span class="hljs-keyword">begin</span>&#123;smallmatrix&#125; a &amp; b \\ c &amp; d \<span class="hljs-keyword">end</span>&#123;smallmatrix&#125;\bigr)<span class="hljs-variable">$ </span>。<br></code></pre></td></tr></table></figure><ul><li>显示：这是一个行中矩阵的示例 <span class="math inline">\(\bigl(\begin{smallmatrix} a &amp; b \\ c &amp; d\end{smallmatrix}\bigr)\)</span> 。</li></ul><h1 id="三方程式序列使用参考">三、方程式序列使用参考</h1><h2 id="输入一个方程式序列">1．输入一个方程式序列</h2><p>人们经常想要一列整齐且居中的方程式序列。使用<code>\begin&#123;align&#125;…\end&#123;align&#125;</code>来创造一列方程式，其中在每行结尾处使用 <code>\\</code>。使用方程式序列无需声明公式符号 <code>$</code> 或 <code>$$</code>。</p><p><strong>请注意 <code>&#123;align&#125;</code> 语句是自动编号的，使用<code>&#123;align*&#125;</code> 声明不自动编号。</strong></p><ul><li>例子：</li></ul><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">\begin</span><span class="hljs-template-variable">&#123;align&#125;</span><span class="language-xml"></span><br><span class="language-xml">    \sqrt</span><span class="hljs-template-variable">&#123;37&#125;</span><span class="language-xml"> &amp; = \sqrt</span><span class="hljs-template-variable">&#123;\frac&#123;73^2-1&#125;</span><span class="hljs-template-variable">&#123;12^2&#125;</span><span class="language-xml">&#125; \\</span><br><span class="language-xml">              &amp; = \sqrt</span><span class="hljs-template-variable">&#123;\frac&#123;73^2&#125;</span><span class="hljs-template-variable">&#123;12^2&#125;</span><span class="language-xml">\cdot\frac</span><span class="hljs-template-variable">&#123;73^2-1&#125;</span><span class="hljs-template-variable">&#123;73^2&#125;</span><span class="language-xml">&#125; \\ </span><br><span class="language-xml">              &amp; = \sqrt</span><span class="hljs-template-variable">&#123;\frac&#123;73^2&#125;</span><span class="hljs-template-variable">&#123;12^2&#125;</span><span class="language-xml">&#125;\sqrt</span><span class="hljs-template-variable">&#123;\frac&#123;73^2-1&#125;</span><span class="hljs-template-variable">&#123;73^2&#125;</span><span class="language-xml">&#125; \\</span><br><span class="language-xml">              &amp; = \frac</span><span class="hljs-template-variable">&#123;73&#125;</span><span class="hljs-template-variable">&#123;12&#125;</span><span class="language-xml">\sqrt</span><span class="hljs-template-variable">&#123;1-\frac&#123;1&#125;</span><span class="hljs-template-variable">&#123;73^2&#125;</span><span class="language-xml">&#125; \\ </span><br><span class="language-xml">              &amp; \approx \frac</span><span class="hljs-template-variable">&#123;73&#125;</span><span class="hljs-template-variable">&#123;12&#125;</span><span class="language-xml">\left(1-\frac</span><span class="hljs-template-variable">&#123;1&#125;</span><span class="hljs-template-variable">&#123;2\cdot73^2&#125;</span><span class="language-xml">\right) \\</span><br><span class="language-xml">\end</span><span class="hljs-template-variable">&#123;align&#125;</span><br></code></pre></td></tr></table></figure><ul><li>显示： <span class="math display">\[\begin{align}  \sqrt{37} &amp; = \sqrt{\frac{73^2-1}{12^2}} \\            &amp; = \sqrt{\frac{73^2}{12^2}\cdot\frac{73^2-1}{73^2}} \\            &amp; = \sqrt{\frac{73^2}{12^2}}\sqrt{\frac{73^2-1}{73^2}}\\            &amp; = \frac{73}{12}\sqrt{1-\frac{1}{73^2}} \\            &amp; \approx\frac{73}{12}\left(1-\frac{1}{2\cdot73^2}\right) \\\end{align}\]</span></li></ul><h2 id="在一个方程式序列的每一行中注明原因">2．在一个方程式序列的每一行中注明原因</h2><p>在 <code>&#123;align&#125;</code> 中后添加 <code>&amp;</code>符号来自动对齐后面的内容，可灵活组合 <code>\text</code> 和<code>\tag</code> 语句。<code>\tag</code>语句编号优先级高于自动编号。</p><ul><li>例子：</li></ul><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\begin&#123;align&#125;</span><br>    v + w &amp; = <span class="hljs-number">0</span>  &amp; <span class="hljs-string">\text&#123;Given&#125;</span> <span class="hljs-string">\tag</span> <span class="hljs-number">1</span> <span class="hljs-string">\\</span><br>       -w &amp; = -w + <span class="hljs-number">0</span> &amp; <span class="hljs-string">\text&#123;additive</span> identity&#125; <span class="hljs-string">\tag</span> <span class="hljs-number">2</span> <span class="hljs-string">\\</span><br>   -w + <span class="hljs-number">0</span> &amp; = -w + (v + w) &amp; <span class="hljs-string">\text&#123;equations</span> $(<span class="hljs-number">1</span>)$ <span class="hljs-keyword">and</span> $(<span class="hljs-number">2</span>)$&#125; <span class="hljs-string">\\</span><br><span class="hljs-string">\end&#123;align&#125;</span><br></code></pre></td></tr></table></figure><ul><li>显示： <span class="math display">\[\begin{align}  v + w &amp; = 0  &amp; \text{Given} \tag 1 \\     -w &amp; = -w + 0 &amp; \text{additive identity} \tag 2 \\-w + 0 &amp; = -w + (v + w) &amp; \text{equations $(1)$ and $(2)$} \\\end{align}\]</span> 本例中第一、第二行的自动编号被 <code>\tag</code>语句覆盖，第三行的编号为自动编号。</li></ul><h1 id="四条件表达式使用参考">四、条件表达式使用参考</h1><h2 id="如何输入一个条件表达式">1．如何输入一个条件表达式</h2><p>使用 <code>\begin&#123;cases&#125;…\end&#123;cases&#125;</code>来创造一组条件表达式，在每一行条件中插入 <code>&amp;</code>来指定需要对齐的内容，并在每一行结尾处使用 <code>\\</code>。</p><ul><li>例子：</li></ul><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br>    f(n) =<br>        \begin&#123;cases&#125;<br>            n/<span class="hljs-number">2</span>,  &amp; \text&#123;<span class="hljs-keyword">if</span> <span class="hljs-symbol">$</span>n<span class="hljs-symbol">$</span> is even&#125; \\<br>            <span class="hljs-number">3</span>n+<span class="hljs-number">1</span>, &amp; \text&#123;<span class="hljs-keyword">if</span> <span class="hljs-symbol">$</span>n<span class="hljs-symbol">$</span> is odd&#125; \\<br>        \end&#123;cases&#125;<br><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><ul><li>显示： <span class="math display">\[  f(n) =      \begin{cases}          n/2,  &amp; \text{if $n$ is even} \\          3n+1, &amp; \text{if $n$ is odd} \\      \end{cases}\]</span></li></ul><h2 id="如何输入一个左侧对齐的条件表达式">2．如何输入一个左侧对齐的条件表达式</h2><p>若想让文字在<strong>左侧对齐显示</strong>，则有如下方式：</p><ul><li>例子：</li></ul><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript">$$<br>    <span class="hljs-string">\left.</span><br>        <span class="hljs-string">\begin&#123;array&#125;&#123;l&#125;</span><br>            <span class="hljs-string">\text&#123;if</span> $n$ <span class="hljs-keyword">is</span> even:&#125; &amp; n/<span class="hljs-number">2</span> <span class="hljs-string">\\</span><br>            <span class="hljs-string">\text&#123;if</span> $n$ <span class="hljs-keyword">is</span> odd:&#125; &amp; <span class="hljs-number">3n</span>+<span class="hljs-number">1</span> <span class="hljs-string">\\</span><br>        <span class="hljs-string">\end&#123;array&#125;</span><br>    <span class="hljs-string">\right\&#125;</span><br>    =f(n)<br>$$<br></code></pre></td></tr></table></figure><ul><li>显示： <span class="math display">\[  \left.      \begin{array}{l}          \text{if $n$ is even:} &amp; n/2 \\          \text{if $n$ is odd:} &amp; 3n+1 \\      \end{array}  \right\}  =f(n)\]</span></li></ul><h2 id="如何使条件表达式适配行高">3．如何使条件表达式适配行高</h2><p>在一些情况下，条件表达式中某些行的行高为非标准高度，此时使用<code>\\[2ex]</code> 语句代替该行末尾的 <code>\\</code>来让编辑器适配。</p><ul><li><p>例子： |不适配[2ex]| |:--:| <figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br>f(n) = <br>    \begin&#123;cases&#125;<br>        \<span class="hljs-built_in">frac</span>&#123;n&#125;&#123;<span class="hljs-number">2</span>&#125;, &amp; \text&#123;<span class="hljs-keyword">if</span> <span class="hljs-symbol">$</span>n<span class="hljs-symbol">$</span> is even&#125; \\<br>        <span class="hljs-number">3</span>n+<span class="hljs-number">1</span>,        &amp; \text&#123;<span class="hljs-keyword">if</span> <span class="hljs-symbol">$</span>n<span class="hljs-symbol">$</span> is odd&#125; \\<br>    \end&#123;cases&#125;<br><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br><br></code></pre></td></tr></table></figure> |适配[2ex]| |:--:|<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br>f(n) = <br>    \begin&#123;cases&#125;<br>        \<span class="hljs-built_in">frac</span>&#123;n&#125;&#123;<span class="hljs-number">2</span>&#125;, &amp; \text&#123;<span class="hljs-keyword">if</span> <span class="hljs-symbol">$</span>n<span class="hljs-symbol">$</span> is even&#125; \\[<span class="hljs-number">2</span>ex]<br>        <span class="hljs-number">3</span>n+<span class="hljs-number">1</span>,        &amp; \text&#123;<span class="hljs-keyword">if</span> <span class="hljs-symbol">$</span>n<span class="hljs-symbol">$</span> is odd&#125; \\<br>    \end&#123;cases&#125;<br><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure></p></li><li><p>显示： |不适配[2ex]|适配[2ex]| |:--:|:--:| <span class="math display">\[f(n) =  \begin{cases}      \frac{n}{2}, &amp; \text{if $n$ is even} \\      3n+1, &amp; \text{if $n$ is odd} \\  \end{cases}\]</span>|<span class="math display">\[f(n) =  \begin{cases}      \frac{n}{2}, &amp; \text{if $n$ is even} \\[2ex]      3n+1, &amp; \text{if $n$ is odd} \\  \end{cases}\]</span></p></li></ul><p><strong>一个 <code>[ex]</code> 指一个 "X-Height"，即 x字母高度。可以根据情况指定多个 <code>[ex]</code>，如<code>[3ex]</code>、<code>[4ex]</code> 等。</strong>其实可以在任意换行处使用 <code>\\[2ex]</code> 语句，只要你觉得合适。</p><h1 id="五.-数组与表格使用参考">五. 数组与表格使用参考</h1><h2 id="如何输入一个数组或表格">1. 如何输入一个数组或表格</h2><p>通常，一个格式化后的表格比单纯的文字或排版后的文字更具有可读性。数组和表格均以 <code>\begin&#123;array&#125;</code>开头，并在其后定义列数及每一列的文本对齐属性，<code>c</code><code>l</code> <code>r</code>分别代表居中、左对齐及右对齐。若需要插入垂直分割线，在定义式中插入<code>|</code> ，若要插入水平分割线，在下一行输入前插入<code>\hline</code> 。 与矩阵相似，每行元素间均须要插入<code>&amp;</code> ，每行元素以 <code>\\</code> 结尾，最后以<code>\ end&#123;array&#125;</code> 结束数组。 使用单个数组或表格时无需声明<code>$</code> 或 <code>$$</code> 符号。</p><ul><li>例子：</li></ul><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\begin&#123;array&#125;&#123;c|lcr&#125;</span><br>    n &amp; <span class="hljs-string">\text&#123;左对齐&#125;</span> &amp; <span class="hljs-string">\text&#123;居中对齐&#125;</span> &amp; <span class="hljs-string">\text&#123;右对齐&#125;</span> <span class="hljs-string">\\</span><br>    <span class="hljs-string">\hline</span><br>    <span class="hljs-number">1</span> &amp; <span class="hljs-number">0.24</span> &amp; <span class="hljs-number">1</span> &amp; <span class="hljs-number">125</span> <span class="hljs-string">\\</span><br>    <span class="hljs-number">2</span> &amp; -<span class="hljs-number">1</span> &amp; <span class="hljs-number">189</span> &amp; -<span class="hljs-number">8</span> <span class="hljs-string">\\</span><br>    <span class="hljs-number">3</span> &amp; -<span class="hljs-number">20</span> &amp; <span class="hljs-number">2000</span> &amp; <span class="hljs-number">1</span>+<span class="hljs-number">10i</span> <span class="hljs-string">\\</span><br><span class="hljs-string">\end&#123;array&#125;</span><br></code></pre></td></tr></table></figure><ul><li>显示： <span class="math display">\[\begin{array}{c|lcr}  n &amp; \text{左对齐} &amp; \text{居中对齐} &amp; \text{右对齐} \\  \hline  1 &amp; 0.24 &amp; 1 &amp; 125 \\  2 &amp; -1 &amp; 189 &amp; -8 \\  3 &amp; -20 &amp; 2000 &amp; 1+10i \\\end{array}\]</span></li></ul><h2 id="如何输入一个嵌套的数组或表格">2．如何输入一个嵌套的数组或表格</h2><p>多个数组*互相嵌套** 并组成一组数组或表格。 使用嵌套前必须声明<code>$$</code> 符号。</p><ul><li>例子：</li></ul><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs tap">$$<br>\begin&#123;array&#125;&#123;c&#125; % 总表格<br>    \begin&#123;array&#125;&#123;cc&#125; % 第一行内分成两列<br>        \begin&#123;array&#125;&#123;c|cccc&#125; % 第一列&quot;最小值&quot;数组<br>            \text&#123;min&#125; &amp;<span class="hljs-number"> 0 </span>&amp;<span class="hljs-number"> 1 </span>&amp;<span class="hljs-number"> 2 </span>&amp;<span class="hljs-number"> 3 </span>\\<br>            \hline<br>           <span class="hljs-number"> 0 </span>&amp;<span class="hljs-number"> 0 </span>&amp;<span class="hljs-number"> 0 </span>&amp;<span class="hljs-number"> 0 </span>&amp;<span class="hljs-number"> 0 </span>\\<br>           <span class="hljs-number"> 1 </span>&amp;<span class="hljs-number"> 0 </span>&amp;<span class="hljs-number"> 1 </span>&amp;<span class="hljs-number"> 1 </span>&amp;<span class="hljs-number"> 1 </span>\\<br>           <span class="hljs-number"> 2 </span>&amp;<span class="hljs-number"> 0 </span>&amp;<span class="hljs-number"> 1 </span>&amp;<span class="hljs-number"> 2 </span>&amp;<span class="hljs-number"> 2 </span>\\<br>           <span class="hljs-number"> 3 </span>&amp;<span class="hljs-number"> 0 </span>&amp;<span class="hljs-number"> 1 </span>&amp;<span class="hljs-number"> 2 </span>&amp;<span class="hljs-number"> 3 </span>\\<br>        \end&#123;array&#125;<br>        &amp;<br>        \begin&#123;array&#125;&#123;c|cccc&#125; % 第二列&quot;最大值&quot;数组<br>            \text&#123;max&#125; &amp;<span class="hljs-number"> 0 </span>&amp;<span class="hljs-number"> 1 </span>&amp;<span class="hljs-number"> 2 </span>&amp;<span class="hljs-number"> 3 </span>\\<br>            \hline<br>           <span class="hljs-number"> 0 </span>&amp;<span class="hljs-number"> 0 </span>&amp;<span class="hljs-number"> 1 </span>&amp;<span class="hljs-number"> 2 </span>&amp;<span class="hljs-number"> 3 </span>\\<br>           <span class="hljs-number"> 1 </span>&amp;<span class="hljs-number"> 1 </span>&amp;<span class="hljs-number"> 1 </span>&amp;<span class="hljs-number"> 2 </span>&amp;<span class="hljs-number"> 3 </span>\\<br>           <span class="hljs-number"> 2 </span>&amp;<span class="hljs-number"> 2 </span>&amp;<span class="hljs-number"> 2 </span>&amp;<span class="hljs-number"> 2 </span>&amp;<span class="hljs-number"> 3 </span>\\<br>           <span class="hljs-number"> 3 </span>&amp;<span class="hljs-number"> 3 </span>&amp;<span class="hljs-number"> 3 </span>&amp;<span class="hljs-number"> 3 </span>&amp;<span class="hljs-number"> 3 </span>\\<br>        \end&#123;array&#125;<br>    \end&#123;array&#125; % 第一行表格组结束<br>    \\<br>    \begin&#123;array&#125;&#123;c|cccc&#125; % 第二行 Delta 值数组<br>        \Delta &amp;<span class="hljs-number"> 0 </span>&amp;<span class="hljs-number"> 1 </span>&amp;<span class="hljs-number"> 2 </span>&amp;<span class="hljs-number"> 3 </span>\\<br>        \hline<br>       <span class="hljs-number"> 0 </span>&amp;<span class="hljs-number"> 0 </span>&amp;<span class="hljs-number"> 1 </span>&amp;<span class="hljs-number"> 2 </span>&amp;<span class="hljs-number"> 3 </span>\\<br>       <span class="hljs-number"> 1 </span>&amp;<span class="hljs-number"> 1 </span>&amp;<span class="hljs-number"> 0 </span>&amp;<span class="hljs-number"> 1 </span>&amp;<span class="hljs-number"> 2 </span>\\<br>       <span class="hljs-number"> 2 </span>&amp;<span class="hljs-number"> 2 </span>&amp;<span class="hljs-number"> 1 </span>&amp;<span class="hljs-number"> 0 </span>&amp;<span class="hljs-number"> 1 </span>\\<br>       <span class="hljs-number"> 3 </span>&amp;<span class="hljs-number"> 3 </span>&amp;<span class="hljs-number"> 2 </span>&amp;<span class="hljs-number"> 1 </span>&amp;<span class="hljs-number"> 0 </span>\\<br>    \end&#123;array&#125; % 第二行表格结束<br>\end&#123;array&#125; % 总表格结束<br>$$<br></code></pre></td></tr></table></figure><ul><li>显示： <span class="math display">\[\begin{array}{c} % 总表格  \begin{array}{cc} % 第一行内分成两列      \begin{array}{c|cccc} % 第一列&quot;最小值&quot;数组          \text{min} &amp; 0 &amp; 1 &amp; 2 &amp; 3 \\          \hline          0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\          1 &amp; 0 &amp; 1 &amp; 1 &amp; 1 \\          2 &amp; 0 &amp; 1 &amp; 2 &amp; 2 \\          3 &amp; 0 &amp; 1 &amp; 2 &amp; 3 \\      \end{array}      &amp;      \begin{array}{c|cccc} % 第二列&quot;最大值&quot;数组          \text{max} &amp; 0 &amp; 1 &amp; 2 &amp; 3 \\          \hline          0 &amp; 0 &amp; 1 &amp; 2 &amp; 3 \\          1 &amp; 1 &amp; 1 &amp; 2 &amp; 3 \\          2 &amp; 2 &amp; 2 &amp; 2 &amp; 3 \\          3 &amp; 3 &amp; 3 &amp; 3 &amp; 3 \\      \end{array}  \end{array} % 第一行表格组结束  \\  \begin{array}{c|cccc} % 第二行 Delta 值数组      \Delta &amp; 0 &amp; 1 &amp; 2 &amp; 3 \\      \hline      0 &amp; 0 &amp; 1 &amp; 2 &amp; 3 \\      1 &amp; 1 &amp; 0 &amp; 1 &amp; 2 \\      2 &amp; 2 &amp; 1 &amp; 0 &amp; 1 \\      3 &amp; 3 &amp; 2 &amp; 1 &amp; 0 \\  \end{array} % 第二行表格结束\end{array} % 总表格结束\]</span></li></ul><h2 id="如何输入一个方程组">3．如何输入一个方程组</h2><p>可以使用 <code>\begin&#123;array&#125; … \end&#123;array&#125;</code> 和<code>\left\&#123; … \right.</code> 来创建一个方程组：</p><ul><li>例子：</li></ul><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript">$$<br><span class="hljs-string">\left\&#123;</span> <br>    <span class="hljs-string">\begin&#123;array&#125;&#123;c&#125;</span><br>        a_1x+b_1y+c_1z=d_1 <span class="hljs-string">\\</span> <br>        a_2x+b_2y+c_2z=d_2 <span class="hljs-string">\\</span> <br>        a_3x+b_3y+c_3z=d_3 <span class="hljs-string">\\</span><br>    <span class="hljs-string">\end&#123;array&#125;</span><br><span class="hljs-string">\right.</span> <br>$$<br></code></pre></td></tr></table></figure><ul><li>显示：</li></ul><p><span class="math display">\[\left\{    \begin{array}{c}        a_1x+b_1y+c_1z=d_1 \\        a_2x+b_2y+c_2z=d_2 \\        a_3x+b_3y+c_3z=d_3 \\    \end{array}\right.\]</span></p><p>或使用条件表达式组 <code>\begin&#123;cases&#125; … \end&#123;cases&#125;</code>来实现相同效果：</p><ul><li>例子：</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">\begin&#123;cases&#125;<br>    a_1x+b_1y+<span class="hljs-attribute">c_1z</span>=d_1 \\ <br>    a_2x+b_2y+<span class="hljs-attribute">c_2z</span>=d_2 \\ <br>    a_3x+b_3y+<span class="hljs-attribute">c_3z</span>=d_3 \\<br>\end&#123;cases&#125;<br></code></pre></td></tr></table></figure><ul><li>显示： <span class="math display">\[\begin{cases}  a_1x+b_1y+c_1z=d_1 \\  a_2x+b_2y+c_2z=d_2 \\  a_3x+b_3y+c_3z=d_3 \\\end{cases}\]</span></li></ul><h1 id="六连分数使用参考">六、连分数使用参考</h1><h2 id="如何输入一个连分式">1．如何输入一个连分式</h2><p>就像输入分式时使用 <code>\frac</code> 一样，使用 <code>\cfrac</code>来创建一个连分数。</p><ul><li>例子：</li></ul><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">$$<br>x = <span class="hljs-built_in">a_0</span> + \cfrac&#123;<span class="hljs-number">1</span>^<span class="hljs-number">2</span>&#125;&#123;<span class="hljs-built_in">a_1</span> +<br>            \cfrac&#123;<span class="hljs-number">2</span>^<span class="hljs-number">2</span>&#125;&#123;<span class="hljs-built_in">a_2</span> +<br>              \cfrac&#123;<span class="hljs-number">3</span>^<span class="hljs-number">2</span>&#125;&#123;<span class="hljs-built_in">a_3</span> +<br>                \cfrac&#123;<span class="hljs-number">4</span>^<span class="hljs-number">4</span>&#125;&#123;<span class="hljs-built_in">a_4</span> + <br>                  \cdots<br>                &#125;<br>              &#125;<br>            &#125;<br>          &#125;<br>$$<br></code></pre></td></tr></table></figure><ul><li>显示： <span class="math display">\[x = a_0 + \cfrac{1^2}{a_1 +          \cfrac{2^2}{a_2 +            \cfrac{3^2}{a_3 +              \cfrac{4^4}{a_4 +                \cdots              }            }          }        }\]</span></li></ul><p>不要使用普通的 <code>\frac</code> 或 <code>\over</code>来生成连分数，这样会看起来<strong>很恶心</strong>。</p><ul><li>反例：</li></ul><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br>x = a_0 + \<span class="hljs-built_in">frac</span>&#123;<span class="hljs-number">1</span>^<span class="hljs-number">2</span>&#125;&#123;a_1 +<br>            \<span class="hljs-built_in">frac</span>&#123;<span class="hljs-number">2</span>^<span class="hljs-number">2</span>&#125;&#123;a_2 +<br>              \<span class="hljs-built_in">frac</span>&#123;<span class="hljs-number">3</span>^<span class="hljs-number">2</span>&#125;&#123;a_3 +<br>                \<span class="hljs-built_in">frac</span>&#123;<span class="hljs-number">4</span>^<span class="hljs-number">4</span>&#125;&#123;a_4 + <br>                  \cdots<br>                &#125;<br>              &#125;<br>            &#125;<br>          &#125;<br><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><ul><li>显示： <span class="math display">\[x = a_0 + \frac{1^2}{a_1 +          \frac{2^2}{a_2 +            \frac{3^2}{a_3 +              \frac{4^4}{a_4 +                \cdots              }            }          }        }\]</span></li></ul><p>当然，你可以使用 <code>\frac</code>来表达连分数的<strong>紧缩记法</strong>。</p><ul><li>例子：</li></ul><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">$$</span><br><span class="language-xml">x = a_0 + \frac</span><span class="hljs-template-variable">&#123;1^2&#125;</span><span class="hljs-template-variable">&#123;a_1 +&#125;</span><span class="language-xml"></span><br><span class="language-xml">          \frac</span><span class="hljs-template-variable">&#123;2^2&#125;</span><span class="hljs-template-variable">&#123;a_2 +&#125;</span><span class="language-xml"></span><br><span class="language-xml">          \frac</span><span class="hljs-template-variable">&#123;3^2&#125;</span><span class="hljs-template-variable">&#123;a_3 +&#125;</span><span class="language-xml"></span><br><span class="language-xml">          \frac</span><span class="hljs-template-variable">&#123;4^4&#125;</span><span class="hljs-template-variable">&#123;a_4 +&#125;</span><span class="language-xml"></span><br><span class="language-xml">          \cdots</span><br><span class="language-xml">$$</span><br></code></pre></td></tr></table></figure><ul><li>显示： <span class="math display">\[x = a_0 + \frac{1^2}{a_1 +}        \frac{2^2}{a_2 +}        \frac{3^2}{a_3 +}        \frac{4^4}{a_4 +}        \cdots\]</span></li></ul><p>连分数通常都太大以至于不易排版，所以建议在连分数前后声明<code>$$</code> 符号，或使用像 <code>[a0,a1,a2,a3,…]</code>一样的紧缩记法。</p>]]></content>
    
    
    <categories>
      
      <category>markdown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>New Start</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>greedy_algorithm</title>
    <link href="/2023/05/28/greedy_algorithm/"/>
    <url>/2023/05/28/greedy_algorithm/</url>
    
    <content type="html"><![CDATA[<h3 id="区间问题">1.区间问题</h3><blockquote><p><strong>区间选点</strong>,给定N个区间,在数轴上选尽量少的点,使得每个区间至少包含一个点. -将每个区间按右端点排序 - 从前往后依次枚举每个区间 -若当前区间已经包含点,continue. - 否则选择当前区间右端点</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    <span class="hljs-keyword">if</span>(ed&lt;f[i].second)&#123;<br>        ed=f[i].first;<br>        ans+=<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>最大不相交区间数量</strong> ,对于N个闭区间,选择其中若干,使得区间不相交,做法思路完全同上题</p></blockquote><blockquote><p><strong>区间分组</strong> ,对于N个区间,分成尽可能少的组数,每组的区间没有交集 -将每个区间按左端点排序 - 从前往后依次枚举每个区间 -判断能否放到某个现有的组当中.(使用左端点比较现有组的右端点) -不存在,开新数组 - 存在,放到旧数组中</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">sort</span>(f,f+n);<br>    <br>priority_queue&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,greater&lt;<span class="hljs-type">int</span>&gt;&gt;heap;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    <span class="hljs-keyword">if</span>(heap.<span class="hljs-built_in">empty</span>()||heap.<span class="hljs-built_in">top</span>()&gt;=f[i].first)&#123;<br>        heap.<span class="hljs-built_in">push</span>(f[i].second);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        heap.<span class="hljs-built_in">push</span>(f[i].second);<br>        heap.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>区间覆盖</strong>,给N个区间和一个目标区间,选尽可能少的区间覆盖目标区间 -将每个区间按左端点排序 - 从前往后依次枚举每个区间 -选择能覆盖目标区间左端点的区间中右端点最大的,将比较值更新成右端点值</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    <span class="hljs-type">int</span> j=i,m=<span class="hljs-number">-2e9</span>;<br>    <span class="hljs-keyword">while</span>(j&lt;n&amp;&amp;x&gt;=f[j].first)&#123; <span class="hljs-comment">//找到右端点最大的包含目标左端点的区间</span><br>        m=<span class="hljs-built_in">max</span>(m,f[j].second); <span class="hljs-comment">//更新目标左端点</span><br>        j++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(m&lt;x)&#123;  <span class="hljs-comment">//不存在,找不到包含左端点的区间</span><br>        res=<span class="hljs-number">-1</span>;<span class="hljs-keyword">break</span>;  <br>    &#125;<br>    res++;<br>    <span class="hljs-keyword">if</span>(m&gt;=y) cout&lt;&lt;res&lt;&lt;endl;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//包含目标区间,输出</span><br>    x=m;<br>    i=j<span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="huffman树">2.huffman树</h3><blockquote><p><strong>合并果子</strong> ,可以任意合并两堆果子. 从小到大的开始合并huffman树,最优二叉树,带权路径长度最短,权重越大离根节点越近</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//使用小根堆存储输入,每次提出栈顶计算即可</span><br>priority_queue&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,greater&lt;<span class="hljs-type">int</span>&gt;&gt;heap;<br></code></pre></td></tr></table></figure><h3 id="排序不等式">3.排序不等式</h3><blockquote><p><strong>排队打水</strong> ,n个人排队到一个水龙头打水,第i人装满水桶时间为 <span class="math inline">\(t_i\)</span>,如何安排使所有人等待时间最小按从小到大顺序排序,时间最少</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;f[i];<br><span class="hljs-built_in">sort</span>(f,f+n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) s[i]=f[i]*(n-i<span class="hljs-number">-1</span>); <span class="hljs-comment">//第i个人打水的时间会被所有人等待的时间和</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) ans+=(<span class="hljs-type">long</span> <span class="hljs-type">long</span>)s[i];<br></code></pre></td></tr></table></figure><h3 id="绝对值不等式">4.绝对值不等式</h3><blockquote><p><strong>货舱选址</strong> ,一条数轴上有N家商店,货仓建在何处使其到每家商店的距离之和最小偶数家商店,选取中间两点的中间值;奇数家商店,选取中心点作为货仓</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(n%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>    x=f[n/<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) ans+=<span class="hljs-built_in">abs</span>(f[i]-x);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    x=f[n/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) ans+=<span class="hljs-built_in">abs</span>(f[i]-x);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="推公式">5.推公式</h3><blockquote><p><strong>耍杂技的牛</strong> ,N头奶牛,第i头重量 <span class="math inline">\(W_i\)</span> ,强壮程度 <span class="math inline">\(S_i\)</span>.使所有牛的风险值中最大的值尽可能最小.风险值是这头牛头上的所有牛的重量减去强壮程度.按照 <span class="math inline">\(w_i+s_i\)</span>从小到大的顺序排,最大的危险系数一定是最小的</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">sort</span>(f,f+n);<br><span class="hljs-type">int</span> ans=<span class="hljs-number">-2e9</span>,weight=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    <span class="hljs-type">int</span> w=f[i].first-f[i].second,s=f[i].second;<br>    ans=<span class="hljs-built_in">max</span>(ans,weight-s);<br>    weight+=w;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dynamic_process</title>
    <link href="/2023/05/24/dynamic_process/"/>
    <url>/2023/05/24/dynamic_process/</url>
    
    <content type="html"><![CDATA[<h3 id="dp分析方法">dp分析方法</h3><blockquote><ul><li>状态表示</li></ul><blockquote><ul><li>集合：设置一个状态集合f[i,j](维度根据要求增减)，将所有可能的情况包含进去</li><li>属性：根据题意判断 max、min、count等</li></ul></blockquote></blockquote><blockquote><ul><li>状态计算</li></ul><blockquote><ul><li>针对状态集合的划分，获得状态转移方程，保证不重不漏</li></ul></blockquote></blockquote><blockquote><p>dp问题可以做的前提是不存在环,是拓扑序</p></blockquote><h3 id="背包">1.背包</h3><h4 id="背包-1">(1)01背包</h4><blockquote><p>N件物品，容量为V的背包，每件物品只能用一次(可以不用)，第i件物品价值为wi，体积为vi。</p></blockquote><blockquote><p><strong><span class="math inline">\(f[i,j]=max(f[i-1,j],f[i-1,j-V^i]+W^i)\)</span></strong>, <span class="math inline">\(f[i,j]\)</span>表示从前i个物品选，体积为j的所有选法，状态集合划分为两类不用第i件物品和使用第i件物品</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//朴素做法</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>        f[i][j] = f[i - <span class="hljs-number">1</span>][j];<br>        <span class="hljs-keyword">if</span> (j &gt;= v[i]) f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - v[i]] + w[i]);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//代码层面的维度优化</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = m; j &gt;= v[i]; j -- )<br>        f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);<br></code></pre></td></tr></table></figure><h4 id="完全背包">(2)完全背包</h4><blockquote><p>N件物品，容量为V的背包，可以用无限次，第i件物品价值为wi，体积为vi。</p></blockquote><blockquote><p><strong><span class="math inline">\(f[i,j]=f[i-1,j-k*v^i]+k*w^i\)</span></strong> ,其中 <span class="math inline">\(f[i,j]\)</span>表示从前i个物品选，体积为j的所有选法，状态集合划分为k(i的选取个数)类，且<span class="math inline">\(k*vi&lt;j\)</span> 。</p></blockquote><blockquote><p><strong>$ f[i,j]=max(f[i-1,j],f[i,j-v^i]+w^i)$</strong> ,将 <span class="math inline">\(f[i,j]\)</span> 和 <span class="math inline">\(f[i,j-v]\)</span>展开可以进行优化获得上述转移方程</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//朴素做法</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;j++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k*v[i]&lt;=j;k++)&#123;<br>            f[i][j]=<span class="hljs-built_in">max</span>(f[i][j],f[i<span class="hljs-number">-1</span>][j-k*v[i]]+k*M[i]);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//优化做法</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=v[i];j&lt;=m;j++)&#123;<br>        f[j]=<span class="hljs-built_in">max</span>(f[j],f[j-v[i]]+M[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="多重背包">(3)多重背包</h4><blockquote><p>N件物品，容量为V的背包，第i件物品最多有 <span class="math inline">\(S^i\)</span> 件，第i件物品价值为wi，体积为vi。</p></blockquote><blockquote><p><strong><span class="math inline">\(f[i,j]=f[i-1,j-k*v^i]+k*w^i\)</span></strong>,其中 <span class="math inline">\(f[i,j]\)</span>表示从前i个物品选，体积为j的所有选法，状态集合划分为k(i的选取个数)类，且<span class="math inline">\(k*vi&lt;j, k&lt;=S^i,O(NVS)\)</span></p></blockquote><blockquote><p>使用二进制优化,对每个物品个数<span class="math inline">\(S^i\)</span>,预处理出<span class="math inline">\(logS^i\)</span>个物品的价值和体积,每个只能使用一次,相当于转化成多个零一背包，<span class="math inline">\(O(NVlogS)\)</span></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//朴素做法</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;j++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k*v[i]&lt;=j&amp;&amp;k&lt;=s[i];k++)&#123;<br>            f[i][j]=<span class="hljs-built_in">max</span>(f[i][j],f[i<span class="hljs-number">-1</span>][j-k*v[i]]+k*M[i]);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//优化</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-type">int</span> a,b,s,k=<span class="hljs-number">1</span>;<br>    cin&gt;&gt;a&gt;&gt;b&gt;&gt;s;<br>    <span class="hljs-keyword">while</span>(k&lt;=s)&#123;<br>        cnt++;<br>        v[cnt]=k*a;<br>        M[cnt]=k*b;<br>        s-=k;<br>        k*=<span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(s!=<span class="hljs-number">0</span>)&#123;<br>        cnt++;<br>        v[cnt]=s*a;<br>        M[cnt]=s*b;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=cnt;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=m;j&gt;=v[i];j--)&#123;<br>        f[j]=<span class="hljs-built_in">max</span>(f[j],f[j-v[i]]+M[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="分组背包">(4)分组背包</h4><blockquote><p>N组物品，容量为V的背包，每组物品若干，同一组内只能选一个，第i件物品价值为wij，体积为vij。</p></blockquote><blockquote><p><strong><span class="math inline">\(f[i,j]=max(f[i-1,j],f[i-1,j-v[i][k]]+w[i][k])\)</span></strong>,其中<span class="math inline">\(f[i,j]\)</span>表示从前i组物品选，体积为j的所有选法，状态集合划分为选第i组的第几个物品或不选</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=m;j&gt;=<span class="hljs-number">0</span>;j--)&#123;  <span class="hljs-comment">//枚举体积</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;s[i];k++)&#123; <span class="hljs-comment">//枚举组内选择</span><br>            <span class="hljs-keyword">if</span>(j&gt;=v[i][k])&#123;<br>                f[j]=<span class="hljs-built_in">max</span>(f[j],f[j-v[i][k]]+w[i][k]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线性dp">2.线性DP</h3><blockquote><ol type="1"><li><strong>数字三角形</strong></li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>        f[i][j]=<span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+a[i][j],f[i<span class="hljs-number">-1</span>][j]+a[i][j]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol start="2" type="1"><li><strong>最长上升子序列</strong>,f[i]，以i结尾的最长的上升子序列的值</li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    f[i]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;i;j++)&#123;<br>        <span class="hljs-keyword">if</span>(a[j]&lt;a[i])<br>            f[i]=<span class="hljs-built_in">max</span>(f[i],f[j]+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol start="3" type="1"><li><strong>最长上升子序列优化</strong>，对于f[i]前面的状态,只需要存长度为1~i-1(如果有的话)的结尾最小的子串就可以了，并且维护的子串数组是严格单调递增的(反证法)$ O(nlogn) $</li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=len;  <span class="hljs-comment">//len就是最长上升子序列</span><br>    <span class="hljs-keyword">while</span>(l&lt;r)&#123;     <span class="hljs-comment">//二分为了找到数组中小于a[i]的最大值</span><br>        <span class="hljs-type">int</span> mid=l+r+<span class="hljs-number">1</span>&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(f[mid]&lt;a[i])l=mid;<br>        <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;<br>    &#125;<br>    len=<span class="hljs-built_in">max</span>(len,r+<span class="hljs-number">1</span>);<br>    f[r+<span class="hljs-number">1</span>]=a[i];    <span class="hljs-comment">//f数组维护单增的长度为1~i的结尾最小的子序列</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol start="4" type="1"><li><strong>最长公共子序列</strong>，f[i,j]，第一个序列的前i个字母和第二个序列的前j个字母出现的最长公共子序列。</li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>        f[i][j]=<span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j],f[i][j<span class="hljs-number">-1</span>]);<br>        <span class="hljs-keyword">if</span>(a[i]==b[j])f[i][j]=f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol start="5" type="1"><li><strong>编辑距离</strong>，f[i,j]所有将a[1,i]变为b[1,j]的操作方式的最小次数</li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)f[i][<span class="hljs-number">0</span>]=i; <span class="hljs-comment">//初始化赋值</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;i++)f[<span class="hljs-number">0</span>][i]=i;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>        f[i][j]=<span class="hljs-built_in">min</span>(f[i<span class="hljs-number">-1</span>][j]+<span class="hljs-number">1</span>,f[i][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>); <span class="hljs-comment">//增加、删除操作</span><br>        <span class="hljs-keyword">if</span>(a[i]==b[j])f[i][j]=<span class="hljs-built_in">min</span>(f[i][j],f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]); <br>        <span class="hljs-keyword">else</span> f[i][j]=<span class="hljs-built_in">min</span>(f[i][j],f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="区间dp">3.区间DP</h3><blockquote><p><strong>石子合并</strong> ,合并相邻石堆,f[i,j]所有将第i堆石子合并成第j堆石子的合并方式的最小值,以最后一次合并的位置进行分类。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len=<span class="hljs-number">2</span>;len&lt;=n;len++)&#123;         <span class="hljs-comment">//按长度遍历</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+len<span class="hljs-number">-1</span>&lt;=n;i++)&#123;     <span class="hljs-comment">//按区间端点遍历</span><br>        <span class="hljs-type">int</span> l=i,r=i+len<span class="hljs-number">-1</span>;<br>        f[l][r]=<span class="hljs-number">1e9</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=l;k&lt;r;k++)&#123;        <span class="hljs-comment">//按合并位置遍历</span><br>            f[l][r]=<span class="hljs-built_in">min</span>(f[l][r],f[l][k]+f[k+<span class="hljs-number">1</span>][r]+s[r]-s[l<span class="hljs-number">-1</span>]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="计数类dp">3.计数类DP</h3><blockquote><p><strong>整数划分</strong>，f[i,j]从1~i中选，恰好为j的数量集合。（完全背包）</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">f[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;=n;j++)&#123;<br>        f[j]=(f[j]+f[j-i])%mod;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//另一种dp划分方式</span><br><span class="hljs-comment">//f[i,j]所有总和是i,且恰好表示成j个数的和的方案,划分为最小值为1,最小值不为1两类</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>        f[i][j]=(f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+f[i-j][j])%mod;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数位统计dp">4.数位统计DP</h3><blockquote><p><strong>计数问题</strong> ,求a-b之间0~9出现的次数</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">001~abc-1, 999</span><br><span class="hljs-comment">abc</span><br><span class="hljs-comment">    1. num[i] &lt; x, 0</span><br><span class="hljs-comment">    2. num[i] == x, 0~efg</span><br><span class="hljs-comment">    3. num[i] &gt; x, 0~999</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dgt</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> <span class="hljs-comment">// 计算整数n有多少位</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n) ++ res, n /= <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> i)</span> <span class="hljs-comment">// 计算从1到n的整数中数字i出现多少次 </span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, d = <span class="hljs-built_in">dgt</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= d; ++ j) <span class="hljs-comment">// 从右到左第j位上数字i出现多少次</span><br>    &#123;<br>        <span class="hljs-comment">// l和r是第j位左边和右边的整数 (abc和efg); dj是第j位的数字</span><br>        <span class="hljs-type">int</span> p = <span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>, j - <span class="hljs-number">1</span>), l = n / p / <span class="hljs-number">10</span>, r = n % p, dj = n / p % <span class="hljs-number">10</span>;<br>        <span class="hljs-comment">// 计算第j位左边的整数小于l (xxx = 000 ~ abc - 1)的情况</span><br>        <span class="hljs-keyword">if</span> (i) res += l * p; <br>        <span class="hljs-keyword">if</span> (!i &amp;&amp; l) res += (l - <span class="hljs-number">1</span>) * p; <span class="hljs-comment">// 如果i = 0, 左边高位不能全为(xxx = 001 ~ abc - 1)</span><br>        <span class="hljs-comment">// 计算第j位左边的整数等于l (xxx = abc)的情况</span><br>        <span class="hljs-keyword">if</span> ( (dj &gt; i) &amp;&amp; (i || l) ) res += p;<br>        <span class="hljs-keyword">if</span> ( (dj == i) &amp;&amp; (i || l) ) res += r + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="状态压缩dp">5.状态压缩DP</h3><blockquote><p><strong>蒙德里安的梦想</strong> ,将NxM的棋盘分割成1x2的长方形的方案数转化成摆放 <strong>横着</strong>的1x2的小方格的方案数(因为竖着的方格只能直接嵌入)</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;n&gt;&gt;m,n||m)&#123;<br>        <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> f); <span class="hljs-comment">//f[n][m] 第一维表示列，第二维表示所有可能的状态</span><br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1</span>&lt;&lt;n;i++)&#123; <span class="hljs-comment">//预处理合法摆放方案,不能有奇数个0</span><br>            <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;   <span class="hljs-comment">//记录中间0的个数</span><br>            st[i]=<span class="hljs-literal">true</span>;  <span class="hljs-comment">//存储每种状态是否有奇数个连续的0,偶数个零置为true。</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(i&gt;&gt;j&amp;<span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(cnt&amp;<span class="hljs-number">1</span>)&#123;<br>                        st[i]=<span class="hljs-literal">false</span>;<br>                    &#125;<br>                    cnt=<span class="hljs-number">0</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> cnt++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(cnt&amp;<span class="hljs-number">1</span>)st[i]=<span class="hljs-literal">false</span>;<br>        &#125;<br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123; <span class="hljs-comment">//枚举每一列</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">1</span>&lt;&lt;n;j++)&#123; <span class="hljs-comment">//枚举状态j</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">1</span>&lt;&lt;n;k++)&#123; <span class="hljs-comment">//枚举状态k</span><br>                    <span class="hljs-keyword">if</span>((j&amp;k)==<span class="hljs-number">0</span>&amp;&amp;st[j|k])<br>                        <span class="hljs-comment">//(j&amp;k)==0代表新横放的格子与前面放好的格子没有冲突</span><br>                        <span class="hljs-comment">//st[j|k]代表j|k的位置不存在连续奇数个0</span><br>                        f[i][j]+=f[i<span class="hljs-number">-1</span>][k];<br>                &#125;<br>            &#125;<br>        &#125;<br>        cout&lt;&lt;f[m][<span class="hljs-number">0</span>]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>最短hamilton路径</strong>,给定带权无向图,从起点0到终点n-1的Hamilton路径(从0到n-1不重不漏的恰好经过每个点一次)f[i,j]所有从0走到j,走过的所有点是 <strong>i(状态)</strong>的所有路径.根据与j相连的前一点k进行划分.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> f);<br>f[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1</span>&lt;&lt;n;i++)&#123;   <span class="hljs-comment">//枚举状态</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;  <span class="hljs-comment">//枚举终点</span><br>        <span class="hljs-keyword">if</span>(i&gt;&gt;j&amp;<span class="hljs-number">1</span>)&#123;        <span class="hljs-comment">//如果路径状态i包含j(可以走到j)</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;n;k++)&#123;  <span class="hljs-comment">//枚举与j相连的k</span><br>                <span class="hljs-keyword">if</span>(i-(<span class="hljs-number">1</span>&lt;&lt;j)&gt;&gt;k&amp;<span class="hljs-number">1</span>)&#123; <span class="hljs-comment">//判断不包含j的路径状态i包含k</span><br>                    f[i][j]=<span class="hljs-built_in">min</span>(f[i][j],f[i-(<span class="hljs-number">1</span>&lt;&lt;j)][k]+a[k][j]);<span class="hljs-comment">//状态转移</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="树形dp">5.树形DP</h3><blockquote><p><strong>没有上司的舞会</strong>,f[i,0],f[i,1]选取这个点和不选这个点的情况.情况划分两种</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">6010</span>;<br><span class="hljs-type">int</span> n,idx,h[N],e[N],ne[N],happy[N],f[N][<span class="hljs-number">2</span>];<br><span class="hljs-type">bool</span> father[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;  <span class="hljs-comment">//建图</span><br>    e[idx]=y,ne[idx]=h[x],h[x]=idx,idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;       <span class="hljs-comment">//树形dp过程</span><br>    f[u][<span class="hljs-number">1</span>]=happy[u];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[u];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>        <span class="hljs-type">int</span> j=e[i];<br>        <span class="hljs-built_in">dfs</span>(j);<br>        f[u][<span class="hljs-number">0</span>]+=<span class="hljs-built_in">max</span>(f[j][<span class="hljs-number">0</span>],f[j][<span class="hljs-number">1</span>]);<br>        f[u][<span class="hljs-number">1</span>]+=f[j][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;happy[i];<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>        <span class="hljs-type">int</span> x,y;<br>        cin&gt;&gt;x&gt;&gt;y;<br>        <span class="hljs-built_in">add</span>(y,x); <span class="hljs-comment">//y-&gt;x,x的父节点是y,建图</span><br>        father[x]=<span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> root=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(father[root])root++; <span class="hljs-comment">//找到根节点</span><br>    <br>    <span class="hljs-built_in">dfs</span>(root);<br>    cout&lt;&lt;<span class="hljs-built_in">max</span>(f[root][<span class="hljs-number">0</span>],f[root][<span class="hljs-number">1</span>])&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="记忆化搜索">6.记忆化搜索</h3><blockquote><p><strong>滑雪</strong> ,只能从高处滑倒低处.f[i,j]所有从(i,j)开始滑的路径.根据滑的方向分为四类</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">310</span>;<br><span class="hljs-type">int</span> n,m,f[N][N],a[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-type">int</span> &amp;v=f[x][y];<br>    <span class="hljs-keyword">if</span>(v!=<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> v;<br>    v=<span class="hljs-number">1</span>;<br><br>    <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,dy[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>        <span class="hljs-type">int</span> fx=x+dx[i],fy=y+dy[i];<br>        <span class="hljs-keyword">if</span>(fx&gt;=<span class="hljs-number">1</span>&amp;&amp;fx&lt;=n&amp;&amp;fy&gt;=<span class="hljs-number">1</span>&amp;&amp;fy&lt;=m&amp;&amp;a[fx][fy]&lt;a[x][y])&#123;<br>            v=<span class="hljs-built_in">max</span>(v,<span class="hljs-built_in">dp</span>(fx,fy)+<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            cin&gt;&gt;a[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> f);<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            res=<span class="hljs-built_in">max</span>(res,<span class="hljs-built_in">dp</span>(i,j));<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;res&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL</title>
    <link href="/2023/05/15/STL/"/>
    <url>/2023/05/15/STL/</url>
    
    <content type="html"><![CDATA[<h3 id="vector-变长数组倍增的思想">1. vector, 变长数组，倍增的思想</h3><ul><li>size() 返回元素个数</li><li>empty() 返回是否为空</li><li>clear() 清空</li><li>front()/back()</li><li>push_back()/pop_back()</li><li>begin()/end()</li><li>[] &gt; 支持比较运算，按字典序</li></ul><h3 id="pairint-int">2. pair&lt;int, int&gt;</h3><ul><li>first, 第一个元素</li><li>second, 第二个元素 &gt;支持比较运算，以first为第一关键字，以second为第二关键字（字典序）</li></ul><h3 id="string字符串">3. string，字符串</h3><ul><li>size()/length() 返回字符串长度</li><li>empty()</li><li>clear()</li><li>substr(起始下标，(子串长度)) 返回子串</li><li>c_str() 返回字符串所在字符数组的起始地址</li></ul><h3 id="queue-队列">4. queue, 队列</h3><ul><li>size()</li><li>empty()</li><li>push() 向队尾插入一个元素</li><li>front() 返回队头元素</li><li>back() 返回队尾元素</li><li>pop() 弹出队头元素</li></ul><h3 id="priority_queue-优先队列默认是大根堆">5. priority_queue,优先队列，默认是大根堆</h3><ul><li>size()</li><li>empty()</li><li>push() 插入一个元素</li><li>top() 返回堆顶元素</li><li>pop() 弹出堆顶元素 &gt; 定义成小根堆的方式：priority_queue&lt;int,vector<int>, greater<int>&gt; q;</int></int></li></ul><h3 id="stack-栈">6. stack, 栈</h3><ul><li>size()</li><li>empty()</li><li>push() 向栈顶插入一个元素</li><li>top() 返回栈顶元素</li><li>pop() 弹出栈顶元素</li></ul><h3 id="deque-双端队列">7. deque, 双端队列</h3><ul><li>size()</li><li>empty()</li><li>clear()</li><li>front()/back()</li><li>push_back()/pop_back()</li><li>push_front()/pop_front()</li><li>begin()/end()</li><li>[]</li></ul><h3 id="set-map-multiset-multimap">8. set, map, multiset, multimap</h3><blockquote><p>基于平衡二叉树（红黑树），动态维护有序序列 - size() - empty() -clear() - begin()/end() - ++, -- 返回前驱和后继，时间复杂度 O(logn)</p></blockquote><ul><li>set/multiset<ul><li>insert() 插入一个数</li><li>find() 查找一个数</li><li>count() 返回某一个数的个数</li><li>erase()<ol type="1"><li>输入是一个数x，删除所有x O(k + logn)</li><li>输入一个迭代器，删除这个迭代器</li></ol></li><li>lower_bound()/upper_bound()<ol type="1"><li>lower_bound(x) 返回大于等于x的最小的数的迭代器</li><li>upper_bound(x) 返回大于x的最小的数的迭代器</li></ol></li></ul></li><li>map/multimap<ul><li>insert() 插入的数是一个pair</li><li>erase() 输入的参数是pair或者迭代器</li><li>find()</li><li>[] 注意multimap不支持此操作。 时间复杂度是 O(logn)</li><li>lower_bound()/upper_bound()</li></ul></li></ul><h3 id="unordered_set-unordered_map-unordered_multiset-unordered_multimap-哈希表">9.unordered_set, unordered_map, unordered_multiset, unordered_multimap,哈希表</h3><blockquote><p>和上面类似，增删改查的时间复杂度是 O(1) 不支持lower_bound()/upper_bound()， 迭代器的++，--</p></blockquote><h3 id="bitset-圧位二进制运算">10. bitset, 圧位,二进制运算</h3><ul><li><p>bitset&lt;10000&gt; s;</p></li><li><p>~, &amp;, |, ^</p></li><li><p>&gt;&gt;, &lt;&lt;</p></li><li><p>==, !=</p></li><li><p>[] 随机存取</p></li><li><p>count() 返回有多少个1</p></li><li><p>any() 判断是否至少有一个1</p></li><li><p>none() 判断是否全为0</p></li><li><p>set() 把所有位置成1</p></li><li><p>set(k, v) 将第k位变成v</p></li><li><p>reset() 把所有位变成0</p></li><li><p>flip() 等价于~</p></li><li><p>flip(k) 把第k位取反</p></li></ul><h3 id="由数据范围反推算法复杂度以及算法内容">由数据范围反推算法复杂度以及算法内容</h3><ul><li><span class="math inline">\(n\leq30\)</span>,指数级别，dfs+剪枝，状态压缩dp</li><li><span class="math inline">\(n\leq100=&gt;O(n^3)\)</span>,floyd,dp,高斯消元</li><li><span class="math inline">\(n\leq1000=&gt;O(n^2),O(n^2logn)\)</span>,dp，二分，朴素版Dijkstra、朴素版Prim、Bellman-Ford</li><li><span class="math inline">\(n\leq10000=&gt;O(n*\sqrt{n})\)</span>,块状链表、分块、莫队</li><li><span class="math inline">\(n\leq1e5=&gt;O(nlogn)\)</span>,各种sort，线段树、树状数组、set/map、heap、拓扑排序、dijkstra+heap、prim+heap、Kruskal、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分、后缀数组、树链剖分、动态树</li><li><span class="math inline">\(n\leq1e6=&gt;O(n)\)</span>单调队列、hash、双指针扫描、并查集，kmp、AC自动机。以及小常数的<span class="math inline">\(O(nlogn)\)</span>,sort、树状数组、heap、dijkstra、spfa</li><li><span class="math inline">\(n\leq1e7=&gt;O(n)\)</span>,双指针扫描、kmp、AC自动机、线性筛素数</li><li><span class="math inline">\(n\leq1e9=&gt;o(\sqrt{n})\)</span>,判断质数</li><li><span class="math inline">\(n\leq1e18=&gt;O(logn)\)</span>,最大公约数，快速幂，数位DP</li><li><span class="math inline">\(n\leq1e1000=&gt;O((logn)^2),O(logk*loglogk)\)</span>高精度加减乘除、FFT/NTT（k表示位数）</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>STL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基本数据结构</title>
    <link href="/2023/05/15/basic_DS/"/>
    <url>/2023/05/15/basic_DS/</url>
    
    <content type="html"><![CDATA[<h3 id="数组模拟链表">1. 数组模拟链表</h3><h4 id="单链表">（1）单链表</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点</span><br><span class="hljs-type">int</span> head, e[N], ne[N], idx;<br><span class="hljs-comment">// 初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    head = <span class="hljs-number">-1</span>;<br>    idx = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 在链表头插入一个数a</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = a, ne[idx] = head, head = idx ++ ;<br>&#125;<br><span class="hljs-comment">// 将头结点删除，需要保证头结点存在</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    head = ne[head];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="双链表">（2）双链表</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点</span><br><span class="hljs-type">int</span> e[N], l[N], r[N], idx;<br><span class="hljs-comment">// 初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//0是左端点，1是右端点</span><br>    r[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>, l[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    idx = <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-comment">// 在节点a的右边插入一个数x</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = x;<br>    l[idx] = a, r[idx] = r[a];<br>    l[r[a]] = idx, r[a] = idx ++ ;<br>&#125;<br><span class="hljs-comment">// 删除节点a</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    l[r[a]] = l[a];<br>    r[l[a]] = r[a];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数组模拟栈">2. 数组模拟栈</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// tt表示栈顶</span><br><span class="hljs-type">int</span> stk[N], tt = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 向栈顶插入一个数</span><br>stk[ ++ tt] = x;<br><span class="hljs-comment">// 从栈顶弹出一个数</span><br>tt -- ;<br><span class="hljs-comment">// 栈顶的值</span><br>stk[tt];<br><span class="hljs-comment">// 判断栈是否为空，如果 tt &gt; 0，则表示不为空</span><br><span class="hljs-keyword">if</span>(tt&gt;<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h4 id="单调栈求每个数左边比它大小的第一个值">单调栈求每个数左边比它大/小的第一个值</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">while</span>(stk.<span class="hljs-built_in">size</span>()&amp;&amp;stk.<span class="hljs-built_in">top</span>()&gt;=q[i]) <span class="hljs-comment">//&lt;=</span><br>            stk.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(!stk.<span class="hljs-built_in">size</span>())cout&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;stk.<span class="hljs-built_in">top</span>()&lt;&lt;endl;<br>        stk.<span class="hljs-built_in">push</span>(q[i]);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="数组模拟队列">3. 数组模拟队列</h3><h4 id="普通队列">（1）普通队列</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// hh 表示队头，tt表示队尾</span><br><span class="hljs-type">int</span> q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><span class="hljs-comment">// 向队尾插入一个数</span><br>q[ ++ tt] = x;<br><span class="hljs-comment">// 从队头弹出一个数</span><br>hh ++ ;<br><span class="hljs-comment">// 队头的值</span><br>q[hh];<br><span class="hljs-comment">// 判断队列是否为空，如果 hh &lt;= tt，则表示不为空</span><br><span class="hljs-keyword">if</span> (hh &lt;= tt)<br></code></pre></td></tr></table></figure><h4 id="双端队列">（2）双端队列</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// hh 表示队头，tt表示队尾的后一个位置</span><br><span class="hljs-type">int</span> q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 向队尾插入一个数</span><br>q[tt ++ ] = x;<br><span class="hljs-keyword">if</span> (tt == N) tt = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 从队头弹出一个数</span><br>hh ++ ;<br><span class="hljs-keyword">if</span> (hh == N) hh = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 队头的值</span><br>q[hh];<br><span class="hljs-comment">// 判断队列是否为空，如果hh != tt，则表示不为空</span><br><span class="hljs-keyword">if</span> (hh != tt)<br></code></pre></td></tr></table></figure><h4 id="滑动窗口求最大值最小值双端队列">（3）滑动窗口求最大值/最小值(双端队列)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    <span class="hljs-keyword">while</span>(dq.<span class="hljs-built_in">size</span>()&amp;&amp;q[dq.<span class="hljs-built_in">back</span>()]&gt;=q[i])dq.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">//&lt;=</span><br>    dq.<span class="hljs-built_in">push_back</span>(i);<br>    <span class="hljs-keyword">if</span>(i&gt;=m<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-keyword">while</span>(dq.<span class="hljs-built_in">front</span>()&lt;=i-m)dq.<span class="hljs-built_in">pop_front</span>();<br>        cout&lt;&lt;q[dq.<span class="hljs-built_in">front</span>()]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="kmp">4. KMP</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度</span><br>求模式串的Next数组：<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= m; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];<br>    <span class="hljs-keyword">if</span> (p[i] == p[j + <span class="hljs-number">1</span>]) j ++ ;<br>    ne[i] = j;<br>&#125;<br><br><span class="hljs-comment">// 匹配</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt;= n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];<br>    <span class="hljs-keyword">if</span> (s[i] == p[j + <span class="hljs-number">1</span>]) j ++ ;<br>    <span class="hljs-keyword">if</span> (j == m)<br>    &#123;<br>        j = ne[j];<br>        <span class="hljs-comment">// 匹配成功后的逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>目的利用字符串的前后缀匹配以使得不用每次回退到从第一位开始比较，<strong>next</strong>数组为匹配字符串的前后缀匹配位数，判断要回退几位，其求法与实际匹配字符串一致。为了减少边界判断，对字符串加<strong>' '</strong> 处理，即字符串从1开始。</p></blockquote><h3 id="trie树">5. trie树</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;  <span class="hljs-comment">//使用结构体初始化</span><br>        <span class="hljs-type">bool</span> is_true;<br>        Node* son[<span class="hljs-number">26</span>];<br>        <span class="hljs-built_in">Node</span>()&#123;<br>            is_true=<span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;i++)&#123;<br>                son[i]=<span class="hljs-literal">nullptr</span>;<br>            &#125;<br>        &#125;<br>    &#125;*root;<br>    <span class="hljs-built_in">Trie</span>() &#123;<br>        root=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string word)</span> </span>&#123; <span class="hljs-comment">//插入</span><br>        <span class="hljs-keyword">auto</span> p=root;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:word)&#123;<br>            <span class="hljs-keyword">auto</span> n=i-<span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(!p-&gt;son[n])p-&gt;son[n]=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>            p=p-&gt;son[n];<br>        &#125;<br>        p-&gt;is_true=<span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(string word)</span> </span>&#123; <span class="hljs-comment">//搜索</span><br>        <span class="hljs-keyword">auto</span> p=root;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:word)&#123;<br>            <span class="hljs-keyword">auto</span> n=i-<span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(!p-&gt;son[n])<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            p=p-&gt;son[n];<br>        &#125;<br>        <span class="hljs-keyword">return</span> p-&gt;is_true;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(string prefix)</span> </span>&#123; <span class="hljs-comment">//判断前缀插入单词是否包含对应前缀</span><br>        <span class="hljs-keyword">auto</span> p=root;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:prefix)&#123;<br>            <span class="hljs-keyword">auto</span> n=i-<span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(!p-&gt;son[n])<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            p=p-&gt;son[n];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>若想用数组实现，需要维护一个数组 <strong>son[N][26]</strong>存储每个节点的子节点, <strong>cnt[N]</strong>以某节点结尾的单词数量,<strong>idx</strong>索引;</p></blockquote><h3 id="并查集">6. 并查集</h3><h4 id="朴素并查集">（1）朴素并查集</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> p[N]; <span class="hljs-comment">//存储每个点的祖宗节点</span><br><span class="hljs-comment">// 返回x的祖宗节点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<span class="hljs-comment">//路径压缩？按秩合并</span><br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) p[i] = i;<br><span class="hljs-comment">// 合并a和b所在的两个集合：</span><br>p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);<br></code></pre></td></tr></table></figure><h4 id="维护size的并查集">（2）维护size的并查集</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> size[N];<br> <span class="hljs-comment">// size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;...&#125;<br><span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&#123;<br>    p[i] = i;<br>    size[i] = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">// 合并a和b所在的两个集合：</span><br>size[<span class="hljs-built_in">find</span>(b)] += size[<span class="hljs-built_in">find</span>(a)];<br>p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);<br></code></pre></td></tr></table></figure><h4 id="维护到祖宗节点的并查集">（3）维护到祖宗节点的并查集</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> p[N], d[N];<br><span class="hljs-comment">//d[x]存储x到p[x]的距离</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x)<br>    &#123;<br>        <span class="hljs-type">int</span> u = <span class="hljs-built_in">find</span>(p[x]);<br>        d[x] += d[p[x]];<br>        p[x] = u;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&#123;<br>    p[i] = i;<br>    d[i] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 合并a和b所在的两个集合：</span><br>p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);<br>d[<span class="hljs-built_in">find</span>(a)] = distance; <span class="hljs-comment">// 根据具体问题，初始化find(a)的偏移量</span><br></code></pre></td></tr></table></figure><h3 id="数组模拟堆">7. 数组模拟堆</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span><br><span class="hljs-comment">// ph[k]存储第k个插入的点在堆中的位置</span><br><span class="hljs-comment">// hp[k]存储堆中下标是k的点是第几个插入的</span><br><span class="hljs-type">int</span> h[N], ph[N], hp[N], size;<br><br><span class="hljs-comment">// 交换两个点，及其映射关系</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">swap</span>(ph[hp[a]],ph[hp[b]]);<br>    <span class="hljs-built_in">swap</span>(hp[a], hp[b]);<br>    <span class="hljs-built_in">swap</span>(h[a], h[b]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t = u;<br>    <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> &lt;= size &amp;&amp; h[u * <span class="hljs-number">2</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= size &amp;&amp; h[u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (u != t)<br>    &#123;<br>        <span class="hljs-built_in">heap_swap</span>(u, t);<br>        <span class="hljs-built_in">down</span>(t);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (u / <span class="hljs-number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="hljs-number">2</span>])<br>    &#123;<br>        <span class="hljs-built_in">heap_swap</span>(u, u / <span class="hljs-number">2</span>);<br>        u &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// O(n)建堆</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span>; i; i -- ) <span class="hljs-built_in">down</span>(i);<br></code></pre></td></tr></table></figure><h3 id="哈希">8. 哈希</h3><h4 id="拉链法">（1）拉链法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> h[N], e[N], ne[N], idx;<br><span class="hljs-comment">// 向哈希表中插入一个数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> k = (x % N + N) % N;<br>    e[idx] = x;<br>    ne[idx] = h[k];<br>    h[k] = idx ++ ;<br>&#125;<br><br><span class="hljs-comment">// 在哈希表中查询某个数是否存在</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> k = (x % N + N) % N;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[k]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        <span class="hljs-keyword">if</span> (e[i] == x)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="开放寻址法">（2）开放寻址法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> h[N];<br><span class="hljs-comment">// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t = (x % N + N) % N;<br>    <span class="hljs-keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)<br>    &#123;<br>        t ++ ;<br>        <span class="hljs-keyword">if</span> (t == N) t = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="字符串哈希">（3）字符串哈希</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ULL;<br>ULL h[N], p[N]; <span class="hljs-comment">// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64</span><br><br><span class="hljs-comment">// 初始化</span><br>p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&#123;<br>    h[i] = h[i - <span class="hljs-number">1</span>] * P + str[i];<br>    p[i] = p[i - <span class="hljs-number">1</span>] * P;<br>&#125;<br><br><span class="hljs-comment">// 计算子串 str[l ~ r] 的哈希值</span><br><span class="hljs-function">ULL <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> h[r] - h[l - <span class="hljs-number">1</span>] * p[r - l + <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>将字符串看成P进制数，P的经验值是 <strong>131或13331</strong>，取这两个值的冲突概率低 注意：取模的数用<strong>2^64</strong>，这样直接用 <strong>unsigned longlong</strong>存储，溢出的结果就是取模的结果</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>DataStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>Data_Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础算法</title>
    <link href="/2023/05/15/basic_algorithm/"/>
    <url>/2023/05/15/basic_algorithm/</url>
    
    <content type="html"><![CDATA[<h2 id="排序二分高精度前缀差分双指针位运算离散化区间合并">排序、二分、高精度、前缀差分、双指针、位运算、离散化、区间合并</h2><figure><img src="/2023/05/15/basic_algorithm/sort.png" title="sort" alt="sort对比"><figcaption aria-hidden="true">sort对比</figcaption></figure><h3 id="quick_sort">1.quick_sort</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r)<span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> i=l<span class="hljs-number">-1</span>,j=r+<span class="hljs-number">1</span>,mid=q[l+r&gt;&gt;<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span>(i&lt;j)&#123;<br>        <span class="hljs-keyword">do</span> i++;<span class="hljs-keyword">while</span>(q[i]&lt;mid);<br>        <span class="hljs-keyword">do</span> j--;<span class="hljs-keyword">while</span>(q[j]&gt;mid);<br>        <span class="hljs-keyword">if</span>(i&lt;j)<span class="hljs-built_in">swap</span>(q[i],q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quicksort</span>(q,l,j);<br>    <span class="hljs-built_in">quicksort</span>(q,j+<span class="hljs-number">1</span>,r);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>分治，确定边界点和mid值，将 <strong>小于</strong>mid的值放到左右两边再递归进行，直到 <strong>l==r</strong> 。</p></blockquote><h3 id="merge_sort">2. merge_sort</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergesort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r)<span class="hljs-keyword">return</span> ;<br>    <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">mergesort</span>(q,l,mid),<span class="hljs-built_in">mergesort</span>(q,mid+<span class="hljs-number">1</span>,r);<br>    <span class="hljs-type">int</span> k=<span class="hljs-number">0</span>,i=l,j=mid+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)&#123;<br>        <span class="hljs-keyword">if</span>(q[i]&lt;=q[j])res[k++]=q[i++];<br>        <span class="hljs-keyword">else</span> res[k++]=q[j++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid)res[k++]=q[i++];<br>    <span class="hljs-keyword">while</span>(j&lt;=r)res[k++]=q[j++];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l,j=<span class="hljs-number">0</span>;i&lt;=r;i++,j++)q[i]=res[j];<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>归并，确定mid值，以mid为界进行划分，直到 <strong>l&gt;r</strong>,开始逐层归并。归并时比较两个数组中值的大小逐个放入，若一数组已经放完则将另一个直接并入后面。</p></blockquote><h3 id="二分">3. 二分</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_1</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">//mid = l+r+1&gt;&gt;1;</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;   <span class="hljs-comment">//l=mid;</span><br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;  <span class="hljs-comment">//r=mid-1;</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><span class="hljs-comment">//浮点数二分</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">bsearch_3</span><span class="hljs-params">(<span class="hljs-type">double</span> l, <span class="hljs-type">double</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;   <span class="hljs-comment">// eps 表示精度，取决于题目对精度的要求</span><br>    <span class="hljs-keyword">while</span> (r - l &gt; eps)<br>    &#123;<br>        <span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高精度">4. 高精度</h3><h4 id="加法">（1）加法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// C = A + B, A &gt;= 0, B &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (A.<span class="hljs-built_in">size</span>() &lt; B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-built_in">add</span>(B, A);<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++ )<br>    &#123;<br>        t += A[i];<br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t += B[i];<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (t) C.<span class="hljs-built_in">push_back</span>(t);<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="减法">（2）减法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, t = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++ )<br>    &#123;<br>        t = A[i] - t;<br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t -= B[i];<br>        C.<span class="hljs-built_in">push_back</span>((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span> (t &lt; <span class="hljs-number">0</span>) t = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="乘法">（3）乘法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// C = A * b, A &gt;= 0, b &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>() || t; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; A.<span class="hljs-built_in">size</span>()) t += A[i] * b;<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="除法">（4）除法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;r)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- )<br>    &#123;<br>        r = r * <span class="hljs-number">10</span> + A[i];<br>        C.<span class="hljs-built_in">push_back</span>(r / b);<br>        r %= b;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(), C.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="前缀和差分">5. 前缀和、差分</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//一维前缀和</span><br>S[i] = a[<span class="hljs-number">1</span>] + a[<span class="hljs-number">2</span>] + ... a[i]<br>a[l] + ... + a[r] = S[r] - S[l - <span class="hljs-number">1</span>]<br><span class="hljs-comment">//二维前缀和</span><br>S[i, j] = 第i行j列格子左上部分所有元素的和<br>以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：<br>S[x2, y2] - S[x1 - <span class="hljs-number">1</span>, y2] - S[x2, y1 - <span class="hljs-number">1</span>] + S[x1 - <span class="hljs-number">1</span>, y1 - <span class="hljs-number">1</span>]<br><br><span class="hljs-comment">//一维差分</span><br>给区间[l, r]中的每个数加上c：B[l] += c, B[r + <span class="hljs-number">1</span>] -= c<br><span class="hljs-comment">//二维差分</span><br>给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：<br>S[x1, y1] += c, S[x2 + <span class="hljs-number">1</span>, y1] -= c, S[x1, y2 + <span class="hljs-number">1</span>] -= c, S[x2 + <span class="hljs-number">1</span>, y2 + <span class="hljs-number">1</span>] += c<br></code></pre></td></tr></table></figure><h3 id="位运算">6. 位运算</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">求n的第k位数字: n &gt;&gt; k &amp; <span class="hljs-number">1</span><br>返回n的最后一位<span class="hljs-number">1</span>：<span class="hljs-built_in">lowbit</span>(n) = n &amp; -n<br></code></pre></td></tr></table></figure><h3 id="离散化">7. 离散化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; alls; <span class="hljs-comment">// 存储所有待离散化的值</span><br><span class="hljs-built_in">sort</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 将所有值排序</span><br>alls.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>()), alls.<span class="hljs-built_in">end</span>());   <span class="hljs-comment">// 去掉重复元素</span><br><br><span class="hljs-comment">// 二分求出x对应的离散化的值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-comment">// 找到第一个大于等于x的位置</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = alls.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (alls[mid] &gt;= x) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r + <span class="hljs-number">1</span>; <span class="hljs-comment">// 映射到1, 2, ...n</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="区间合并">8. 区间合并</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;res)</span></span>&#123;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;path;<br>    <span class="hljs-built_in">sort</span>(res.<span class="hljs-built_in">begin</span>(),res.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">1</span>,l=res[<span class="hljs-number">0</span>].first,r=res[<span class="hljs-number">0</span>].second;<br>    <span class="hljs-comment">//cout&lt;&lt;res.size();</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;res.<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-keyword">if</span>(res[i].first&lt;=r)r=<span class="hljs-built_in">max</span>(res[i].second,r);<br>        <span class="hljs-keyword">else</span>&#123;<br>            ans++;<br>            path.<span class="hljs-built_in">push_back</span>(&#123;l,r&#125;);<br>            l=res[i].first;<br>            r=res[i].second;<br>        &#125;<br>    &#125;<br>    path.<span class="hljs-built_in">push_back</span>(&#123;l,r&#125;);  <span class="hljs-comment">//ans为区间个数，path为具体区间范围</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础数学相关算法</title>
    <link href="/2023/05/15/math/"/>
    <url>/2023/05/15/math/</url>
    
    <content type="html"><![CDATA[<h2 id="数学相关">数学相关</h2><h3 id="质数">1.质数</h3><h4 id="试除法判定质数-osqrtn">(1)试除法判定质数 <span class="math inline">\(O(\sqrt{n})\)</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++ )<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="分解质因数">(2)分解质因数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++ )<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>) <span class="hljs-comment">//i一定为质数,因为i一定不会被2~i-1间的数整除</span><br>        &#123;<br>            <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>) x /= i, s ++ ;<br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; endl;<br>        &#125;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="朴素筛质数-onlnn">(3)朴素筛质数 <span class="math inline">\(O(nlnn)\)</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> primes[N], cnt;     <span class="hljs-comment">// primes[]存储所有素数</span><br><span class="hljs-type">bool</span> st[N];         <span class="hljs-comment">// st[x]存储x是否被筛掉</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!st[i])&#123;<br>            primes[cnt ++ ] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + i; j &lt;= n; j += i) st[j] = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>埃氏筛法 <span class="math inline">\(O(nloglogn)\)</span>只用质数去筛选</p></blockquote><h4 id="线性筛法-on">(4)线性筛法 <span class="math inline">\(O(n)\)</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> primes[N], cnt;     <span class="hljs-comment">// primes[]存储所有素数</span><br><span class="hljs-type">bool</span> st[N];         <span class="hljs-comment">// st[x]存储x是否被筛掉</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!st[i]) primes[cnt ++ ] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= n / i; j ++ )<br>        &#123;<br>            st[primes[j] * i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>n只会被最小质因子筛掉</p></blockquote><h3 id="约数">2.约数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">get_divisors</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= x / i; i ++ )<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-keyword">if</span> (i != x / i) res.<span class="hljs-built_in">push_back</span>(x / i);<br>        &#125;<br>    <span class="hljs-built_in">sort</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>如果 <strong><span class="math inline">\(N=p1^{c1}+p2^{c2}+\dotspk^{ck}\)</span></strong><br>约数个数： <strong><span class="math inline">\((c1 + 1) * (c2 + 1) * ...* (ck + 1)\)</span></strong><br>约数之和： <strong><span class="math inline">\((p1^0 + p1^1 + ... +p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck)\)</span></strong></p></blockquote><h4 id="最大公约数欧几里得">最大公约数(欧几里得)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> b ? <span class="hljs-built_in">gcd</span>(b, a % b) : a;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="欧拉函数1n中与n互质的数的个数">3.欧拉函数(1~n中与n互质的数的个数)</h3><blockquote><p>$ N=p_1^{a 1}p_2^{a 2}... p_k^{a k}$<br><span class="math inline">\(\phi(N)=N(1-\dfrac{1}{p_1})(1-\dfrac{1}{p_2})\dots(1-\dfrac{1}{p_k})\)</span><br>使用上述公式求欧拉函数</p></blockquote><h4 id="朴素做法求欧拉函数onsqrtn">(1)朴素做法求欧拉函数<span class="math inline">\(O(n\sqrt{n})\)</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">phi</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++ )<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>)<br>        &#123;<br>            res = res / i * (i - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>) x /= i;<br>        &#125;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) res = res / x * (x - <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="筛法求欧拉函数">(2)筛法求欧拉函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> primes[N], cnt;     <span class="hljs-comment">// primes[]存储所有素数</span><br><span class="hljs-type">int</span> euler[N];           <span class="hljs-comment">// 存储每个数的欧拉函数</span><br><span class="hljs-type">bool</span> st[N];         <span class="hljs-comment">// st[x]存储x是否被筛掉</span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_eulers</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    euler[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!st[i])<br>        &#123;<br>            primes[cnt ++ ] = i;<br>            euler[i] = i - <span class="hljs-number">1</span>;<span class="hljs-comment">//若i为质数，说明与它互质的个数就是i-1</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= n / i; j ++ )<br>        &#123;<br>            <span class="hljs-type">int</span> t = primes[j] * i;<br>            st[t] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>)<br>            &#123;<br>                euler[t] = euler[i] * primes[j];<span class="hljs-comment">//i可以被primes[j]整除说明t和i的质数一样，对比公式只有N不一样，所以只用乘primes[j]</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            euler[t] = euler[i] * (primes[j] - <span class="hljs-number">1</span>);<span class="hljs-comment">//i不能被整除，N乘以primes[j]后面还要乘以(1-primes[j]/1),整理得出</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="快速幂">4.快速幂</h3><blockquote><p>求$ a^k mod p$，时间复杂度 <span class="math inline">\(O(logk)\)</span><br>预处理出来 <span class="math inline">\(a^{2^{0-logk}}modp\)</span>的值，将 <span class="math inline">\(a^k\)</span> 拆成 <span class="math inline">\(a^{2^0\dots2^{logk}}\)</span> 的和</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span> % p, t = a;<br>    <span class="hljs-keyword">while</span> (k)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (k&amp;<span class="hljs-number">1</span>) res = res * t % p;<br>        t = t * t % p;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="扩展欧几里得">5.扩展欧几里得</h3><blockquote><p>求x, y，使得ax + by = gcd(a, b)</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!b)<br>    &#123;<br>        x = <span class="hljs-number">1</span>; y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-type">int</span> d = <span class="hljs-built_in">exgcd</span>(b, a % b, y, x);<br>    y -= (a/b) * x;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高斯消元">6.高斯消元</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// a[N][N]是增广矩阵</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gauss</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> c, r;<br>    <span class="hljs-keyword">for</span> (c = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>; c &lt; n; c ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> t = r;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = r; i &lt; n; i ++ )   <span class="hljs-comment">// 找到绝对值最大的行</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(a[i][c]) &gt; <span class="hljs-built_in">fabs</span>(a[t][c]))<br>                t = i;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(a[t][c]) &lt; eps) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = c; i &lt;= n; i ++ ) <span class="hljs-built_in">swap</span>(a[t][i], a[r][i]);      <span class="hljs-comment">// 将绝对值最大的行换到最顶端</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= c; i -- ) a[r][i] /= a[r][c];      <span class="hljs-comment">// 将当前行的首位变成1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = r + <span class="hljs-number">1</span>; i &lt; n; i ++ )       <span class="hljs-comment">// 用当前行将下面所有的列消成0</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(a[i][c]) &gt; eps)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n; j &gt;= c; j -- )<br>                    a[i][j] -= a[r][j] * a[i][c];<br><br>        r ++ ;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (r &lt; n)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = r; i &lt; n; i ++ )<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(a[i][n]) &gt; eps)<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>; <span class="hljs-comment">// 无解</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 有无穷多组解</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j ++ )<br>            a[i][n] -= a[i][j] * a[j][n];<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 有唯一解</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="组合数">7.组合数</h3><h4 id="递推法求组合数">（1）递推法求组合数</h4><blockquote><p><span class="math inline">\(C_a^b=C_{a-1}^b+C_{a-1}^{b-1}=\dfrac{a!}{b!(a-b)!}\)</span></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// c[a][b] 表示从a个苹果中选b个的方案数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i ++ )<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j ++ )<br>        <span class="hljs-keyword">if</span> (!j) c[i][j] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> c[i][j] = (c[i - <span class="hljs-number">1</span>][j] + c[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) % mod;<br></code></pre></td></tr></table></figure><h4 id="预处理逆元求组合数">（2）预处理逆元求组合数</h4><blockquote><p>首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N]如果取模的数是质数，可以用费马小定理求逆元</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> p)</span>    <span class="hljs-comment">// 快速幂模板</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (k)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) res = (LL)res * a % p;<br>        a = (LL)a * a % p;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// 预处理阶乘的余数和阶乘逆元的余数</span><br>fact[<span class="hljs-number">0</span>] = infact[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i ++ )<br>&#123;<br>    fact[i] = (LL)fact[i - <span class="hljs-number">1</span>] * i % mod;<br>    infact[i] = (LL)infact[i - <span class="hljs-number">1</span>] * <span class="hljs-built_in">qmi</span>(i, mod - <span class="hljs-number">2</span>, mod) % mod;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="lucas定理">（3）lucas定理</h4><blockquote><p>若p是质数，则对于任意整数 1 &lt;= m &lt;= n，有： <strong><span class="math inline">\(C(n, m) = C(n \% p, m \% p) * C(n / p, m / p) (modp)\)</span></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> p)</span>  <span class="hljs-comment">// 快速幂模板</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span> % p;<br>    <span class="hljs-keyword">while</span> (k)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) res = (LL)res * a % p;<br>        a = (LL)a * a % p;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> p)</span>  <span class="hljs-comment">// 通过定理求组合数C(a, b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (a &lt; b) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    LL x = <span class="hljs-number">1</span>, y = <span class="hljs-number">1</span>;  <span class="hljs-comment">// x是分子，y是分母</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = a, j = <span class="hljs-number">1</span>; j &lt;= b; i --, j ++ )<br>    &#123;<br>        x = (LL)x * i % p;<br>        y = (LL) y * j % p;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> x * (LL)<span class="hljs-built_in">qmi</span>(y, p - <span class="hljs-number">2</span>, p) % p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lucas</span><span class="hljs-params">(LL a, LL b, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (a &lt; p &amp;&amp; b &lt; p) <span class="hljs-keyword">return</span> <span class="hljs-built_in">C</span>(a, b, p);<br>    <span class="hljs-keyword">return</span> (LL)<span class="hljs-built_in">C</span>(a % p, b % p, p) * <span class="hljs-built_in">lucas</span>(a / p, b / p, p) % p;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="分解质因数求组合数">（4）分解质因数求组合数</h4><blockquote><p>当需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用：<br>1. 筛法求出范围内的所有质数<br>2. 通过 <strong><span class="math inline">\(C(a, b) = a! / b! / (a -b)!\)</span></strong> 这个公式求出每个质因子的次数。 n! 中p的次数是<strong><span class="math inline">\(n / p + n / p^2 + n / p^3 +...\)</span></strong><br>3. 用高精度乘法将所有质因子相乘</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> primes[N], cnt;     <span class="hljs-comment">// 存储所有质数</span><br><span class="hljs-type">int</span> sum[N];     <span class="hljs-comment">// 存储每个质数的次数</span><br><span class="hljs-type">bool</span> st[N];     <span class="hljs-comment">// 存储每个数是否已被筛掉</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>      <span class="hljs-comment">// 线性筛法求素数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!st[i]) primes[cnt ++ ] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= n / i; j ++ )<br>        &#123;<br>            st[primes[j] * i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> p)</span>       <span class="hljs-comment">// 求n！中的次数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n)<br>    &#123;<br>        res += n / p;<br>        n /= p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; a, <span class="hljs-type">int</span> b)</span>       <span class="hljs-comment">// 高精度乘低精度模板</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; c;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-built_in">size</span>(); i ++ )<br>    &#123;<br>        t += a[i] * b;<br>        c.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (t)<br>    &#123;<br>        c.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br><span class="hljs-built_in">get_primes</span>(a);  <span class="hljs-comment">// 预处理范围内的所有质数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i ++ )     <span class="hljs-comment">// 求每个质因数的次数</span><br>&#123;<br>    <span class="hljs-type">int</span> p = primes[i];<br>    sum[i] = <span class="hljs-built_in">get</span>(a, p) - <span class="hljs-built_in">get</span>(b, p) - <span class="hljs-built_in">get</span>(a - b, p);<br>&#125;<br>vector&lt;<span class="hljs-type">int</span>&gt; res;<br>res.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i ++ )     <span class="hljs-comment">// 用高精度乘法将所有质因子相乘</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; sum[i]; j ++ )<br>        res = <span class="hljs-built_in">mul</span>(res, primes[i]);<br></code></pre></td></tr></table></figure><h3 id="卡特兰数">8.卡特兰数</h3><blockquote><p>给定n个0和n个1，它们按照某种顺序排成长度为2n的序列，满足任意前缀中0的个数都不少于1的个数的序列的数量为：<strong><span class="math inline">\(Cat(n) = C(2n, n) / (n +1)\)</span></strong><br>&gt; Nim : A1 ^ A2 ^ … ^ An != 0 先手必胜<br>&gt; SG：SG(x) = mex({SG(y1), SG(y2), …,SG(yk)})，其中mex(S)为求出不属于集合S的最小非负整数的运算，mex(S) =min{x}</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搜索与图论</title>
    <link href="/2023/05/15/search_graph/"/>
    <url>/2023/05/15/search_graph/</url>
    
    <content type="html"><![CDATA[<h2 id="深搜宽搜树和图的遍历存储">深搜、宽搜、树和图的遍历存储</h2><h3 id="树与图的存储">1. 树与图的存储</h3><h4 id="邻接矩阵维护二维矩阵给gab存储边a-b稠密图">（1）邻接矩阵，维护二维矩阵给G[a][b]存储边a-&gt;b，稠密图</h4><h4 id="邻接表存储稀疏图">（2）邻接表，存储稀疏图</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点</span><br><span class="hljs-type">int</span> h[N], e[N], ne[N], idx;<br><span class="hljs-comment">// 添加一条边a-&gt;b</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;<br>&#125;<br><span class="hljs-comment">// 初始化</span><br>idx = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br></code></pre></td></tr></table></figure><blockquote><p>树是一种特殊的图结构，与图的存储方式相同，对于无向图，相当于存储两条边a-&gt;b,b-&gt;a.</p></blockquote><h3 id="树和图的遍历">2. 树和图的遍历</h3><blockquote><p>时间复杂度为<span class="math inline">\(O(n+m)\)</span></p></blockquote><h4 id="深度优先遍历dfs">（1）深度优先遍历dfs</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    st[u] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// st[u] 表示点u已经被遍历过</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!st[j]) <span class="hljs-built_in">dfs</span>(j);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="宽度优先遍历bfs">（2）宽度优先遍历bfs</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp">queue&lt;<span class="hljs-type">int</span>&gt; q;<br>st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 表示1号点已经被遍历过</span><br>q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>&#123;<br>    <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>    q.<span class="hljs-built_in">pop</span>();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!st[j])<br>        &#123;<br>            st[j] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 表示点j已经被遍历过</span><br>            q.<span class="hljs-built_in">push</span>(j);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="拓扑排序">3.拓扑排序</h3><blockquote><p>时间复杂度为<span class="math inline">\(O(n+m)\)</span>,有向无环图UAG一定存在拓扑序</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">topsort</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//类似于层序遍历</span><br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(d[i]==<span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">//根据入度是否为零判断是否加入栈中</span><br>            q.<span class="hljs-built_in">push</span>(i);<br>            ct++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-type">int</span> t=q.<span class="hljs-built_in">front</span>();<br>        g[k++]=t;<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[t];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>            <span class="hljs-type">int</span> j=e[i];<br>            d[j]--;<br>            <span class="hljs-keyword">if</span>(d[j]==<span class="hljs-number">0</span>)&#123;<br>                q.<span class="hljs-built_in">push</span>(j);<br>                ct++;<br>            &#125;<br>        &#125;   <br>    &#125;<br>    <span class="hljs-keyword">return</span> ct==n;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="dijkstra">4.dijkstra</h3><h4 id="朴素版本">（1）朴素版本</h4><blockquote><p><span class="math inline">\(O(n^2+m)\)</span>单源最短路，所有边权都是正数。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> g[N][N];  <span class="hljs-comment">// a-&gt;b权重</span><br><span class="hljs-type">int</span> dist[N];  <span class="hljs-comment">// 存储1号点到每个点的最短距离</span><br><span class="hljs-type">bool</span> st[N];   <span class="hljs-comment">// 每个点的最短路是否已经确定</span><br><span class="hljs-type">int</span> pre[N];  <span class="hljs-comment">//存储最短路径</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)pre[i]=i;<span class="hljs-comment">//初始化将前驱指向自己</span><br><span class="hljs-comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;     <span class="hljs-comment">// 在还未确定最短路的点中，寻找距离最小的点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[t] &gt; dist[j]))<br>                t = j;<br><br>        <span class="hljs-comment">// 用t更新其他点的距离，同时求最短路径</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            dist[j] = <span class="hljs-built_in">min</span>(dist[j], dist[t] + g[t][j]);<br>            pre[j]=t;<br><br>        st[t] = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>有可能会存在多条最短路，每条边额外增加边权重cost，让选取cost最小的最短路径，只需再维护cost数组，在用t更新其它点的距离时特判<strong>dist[j]==dist[t]+g[t][j]&amp;&amp;cost[j]&gt;cost[t]+cost[t][j]</strong>.</li></ul></blockquote><blockquote><ul><li>求出有多少条最短路径，维护一个数组num[],初始化为1，其余为0，距离不同时直接更新，距离相同时累加<strong>num[j]+=num[t]</strong>;</li></ul></blockquote><h4 id="堆优化版本">（2）堆优化版本</h4><blockquote><p><span class="math inline">\(O(mlogn)\)</span>单源最短路，所有边权都是正数.将最近未确定的点的时间复杂度变为O(1),用邻接表存储稀疏图，用优先队列存堆，每次取出堆顶，更新堆顶的所有出边，更新过的放入队列中。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-type">int</span> n;      <span class="hljs-comment">// 点的数量</span><br><span class="hljs-type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="hljs-comment">// 邻接表存储所有边</span><br><span class="hljs-type">int</span> dist[N];        <span class="hljs-comment">// 存储所有点到1号点的距离</span><br><span class="hljs-type">bool</span> st[N];     <span class="hljs-comment">// 存储每个点的最短距离是否已确定</span><br><br><span class="hljs-comment">// 求1号点到n号点的最短距离，如果不存在，则返回-1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;<br>    heap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;);      <span class="hljs-comment">// first存储距离，second存储节点编号</span><br><br>    <span class="hljs-keyword">while</span> (heap.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = heap.<span class="hljs-built_in">top</span>();<br>        heap.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-type">int</span> ver = t.second, distance = t.first;<br><br>        <span class="hljs-keyword">if</span> (st[ver]) <span class="hljs-keyword">continue</span>;<br>        st[ver] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[ver]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; distance + w[i])<br>            &#123;<br>                dist[j] = distance + w[i];<br>                heap.<span class="hljs-built_in">push</span>(&#123;dist[j], j&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="bellman-ford">5.Bellman-Ford</h3><blockquote><p><span class="math inline">\(O(nm)\)</span>存在负权边，可以用来判断有无负权回路 。 遍历每个点，再遍历每条边</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n,m,k;  <span class="hljs-comment">//限制走k次</span><br><span class="hljs-type">int</span> dist[N],backup[N];<span class="hljs-comment">//backup防止串联</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123; <span class="hljs-comment">//用结构体存边权关系</span><br>    <span class="hljs-type">int</span> a,b,c;<br>&#125;edge[M];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>        <span class="hljs-built_in">memcpy</span>(backup,dist,<span class="hljs-keyword">sizeof</span> dist);<span class="hljs-comment">//确保每次更新只用上一次的结果</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            <span class="hljs-keyword">auto</span> e=edge[j];<br>            dist[e.b]=<span class="hljs-built_in">min</span>(dist[e.b],backup[e.a]+e.c);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dist[n]&gt;<span class="hljs-number">0x3f3f3f3f</span>/<span class="hljs-number">2</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0x3f3f3f3f</span>; <span class="hljs-comment">//存在负权边可能使dist[N]发生变化</span><br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="spfa队列优化的bellman-ford">spfa(队列优化的Bellman-Ford)</h4><blockquote><p>平均情况O(m),最坏情况下O(n+m)</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n;      <span class="hljs-comment">// 总点数</span><br><span class="hljs-type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="hljs-comment">// 邻接表存储所有边</span><br><span class="hljs-type">int</span> dist[N];        <span class="hljs-comment">// 存储每个点到1号点的最短距离</span><br><span class="hljs-type">bool</span> st[N];     <span class="hljs-comment">// 存储每个点是否在队列中</span><br><br><span class="hljs-comment">// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br><br>        st[t] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i])<br>            &#123;<br>                dist[j] = dist[t] + w[i];<br>                <span class="hljs-keyword">if</span> (!st[j])     <span class="hljs-comment">// 如果队列中已存在j，则不需要将j重复插入</span><br>                &#123;<br>                    q.<span class="hljs-built_in">push</span>(j);<br>                    st[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="spfa判断是否存在环">spfa判断是否存在环</h4><blockquote><p>额外维护一个cnt[N]数组记录边数,跟随距离一起更新</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">dist[j] = dist[t] + w[i];<br>cnt[j] = cnt[t] + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (cnt[j] &gt;= n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br></code></pre></td></tr></table></figure><blockquote><ul><li>可以用并查集判断无向图是否有环</li><li>使用拓扑排序根据节点度判断有向图是否有环(无向图需要节点度&lt;=1)</li><li>dfs,用一个状态数组表示节点是否被使用，若dfs过程中出现已经被使用过的节点说明有环。</li></ul></blockquote><h3 id="floyd">6.floyd</h3><blockquote><p><span class="math inline">\(O(n^3)\)</span>,n为点数,多源最短路，可以存在负权边，基于动态规划</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//初始化</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>        <span class="hljs-keyword">if</span> (i == j) d[i][j] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span> d[i][j] = INF;<br><br><span class="hljs-comment">// 算法结束后，d[a][b]表示a到b的最短距离</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>                d[i][j] = <span class="hljs-built_in">min</span>(d[i][j], d[i][k] + d[k][j]);<span class="hljs-comment">//i到j的最短路</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最小生成树">7.最小生成树</h3><h4 id="prim">（1）prim</h4><blockquote><p><span class="math inline">\(O(n^2+m)\)</span></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n;      <span class="hljs-comment">// n表示点数</span><br><span class="hljs-type">int</span> g[N][N];        <span class="hljs-comment">// 邻接矩阵，存储所有边</span><br><span class="hljs-type">int</span> dist[N];        <span class="hljs-comment">// 存储其他点到当前最小生成树的距离</span><br><span class="hljs-type">bool</span> st[N];     <span class="hljs-comment">// 存储每个点是否已经在生成树中</span><br><span class="hljs-comment">// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[t] &gt; dist[j]))<br>                t = j;<br><br>        <span class="hljs-keyword">if</span> (i &amp;&amp; dist[t] == INF) <span class="hljs-keyword">return</span> INF;<span class="hljs-comment">//说明图不连通</span><br><br>        <span class="hljs-keyword">if</span> (i) res += dist[t];<br>        st[t] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ ) dist[j] = <span class="hljs-built_in">min</span>(dist[j], g[t][j]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="堆优化版prim">（2）堆优化版prim</h4><blockquote><p><span class="math inline">\(O(mlogn)\)</span>，类似于dijkstra堆优化</p></blockquote><h4 id="kruskal">（3）Kruskal</h4><blockquote><p><span class="math inline">\(O(mlogm)\)</span>最小生成树(由全部点和n-1条边组成的无向连通图为生成树，其中权值最小的那个)，利用了并查集。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n, m;       <span class="hljs-comment">// n是点数，m是边数</span><br><span class="hljs-type">int</span> p[N];       <span class="hljs-comment">// 并查集的父节点数组</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>     <span class="hljs-comment">// 存储边</span><br>&#123;<br>    <span class="hljs-type">int</span> a, b, w;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-type">const</span> Edge &amp;W)<span class="hljs-type">const</span>  <span class="hljs-comment">//函数重载</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> w &lt; W.w;<br>    &#125;<br>&#125;edges[M];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>     <span class="hljs-comment">// 并查集核心操作</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">sort</span>(edges, edges + m);<span class="hljs-comment">//将所有边按权重从小到大排</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) p[i] = i;    <span class="hljs-comment">// 初始化并查集</span><br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;<br><br>        a = <span class="hljs-built_in">find</span>(a), b = <span class="hljs-built_in">find</span>(b);<br>        <span class="hljs-keyword">if</span> (a != b)     <span class="hljs-comment">// 如果两个连通块不连通，则将这两个连通块合并</span><br>        &#123;<br>            p[a] = b;<br>            res += w; <span class="hljs-comment">//记录权重值</span><br>            cnt ++ ; <span class="hljs-comment">//cnt判断边的数量</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (cnt &lt; n - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> INF;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二分图">8.二分图</h3><h4 id="染色法">（1）染色法</h4><blockquote><p><span class="math inline">\(O(n+m)\)</span>,一个图是二分图(集合中没有边)当且仅当图中不含奇数环(边的数量为奇数)</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n;      <span class="hljs-comment">// n表示点数</span><br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx;     <span class="hljs-comment">// 邻接表存储图</span><br><span class="hljs-type">int</span> color[N];       <span class="hljs-comment">// 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色</span><br><br><span class="hljs-comment">// 参数：u表示当前节点，c表示当前点的颜色</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    color[u] = c;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (color[j] == <span class="hljs-number">-1</span>)<span class="hljs-comment">//没染色</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dfs</span>(j, !c)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (color[j] == c) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//染过色</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(color, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> color);<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<span class="hljs-comment">//遍历所有点</span><br>        <span class="hljs-keyword">if</span> (color[i] == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dfs</span>(i, <span class="hljs-number">0</span>))<br>            &#123;<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>    <span class="hljs-keyword">return</span> flag;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="匈牙利算法">（2）匈牙利算法</h4><blockquote><p><span class="math inline">\(O(nm)\)</span>,但实际运行时间通常远小于nm，二分图的最大匹配(没有相同顶点的边的集合)</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n1, n2;     <span class="hljs-comment">// n1表示第一个集合中的点数，n2表示第二个集合中的点数</span><br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx;     <span class="hljs-comment">// 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边</span><br><span class="hljs-type">int</span> match[N];       <span class="hljs-comment">// 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个</span><br><span class="hljs-type">bool</span> st[N];     <span class="hljs-comment">// 表示第二个集合中的每个点是否已经被遍历过</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[x]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!st[j])<br>        &#123;<br>            st[j] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (match[j] == <span class="hljs-number">0</span> || <span class="hljs-built_in">find</span>(match[j]))<span class="hljs-comment">//判断j有没有被匹配过或者match[j]能不能匹配到其他点</span><br>            &#123;<br>                match[j] = x;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点</span><br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n1; i ++ )<br>&#123;<br>    <span class="hljs-built_in">memset</span>(st, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span> st);<span class="hljs-comment">//每次都要重置st，考虑集合n2中的每个点</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(i)) res ++ ;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MarkDown</title>
    <link href="/2023/05/09/My-New-Post/"/>
    <url>/2023/05/09/My-New-Post/</url>
    
    <content type="html"><![CDATA[<h1 id="markdown-简明语法手册">Markdown 简明语法手册</h1><h3 id="斜体和粗体">1. 斜体和粗体</h3><p>使用 * 和 ** 表示斜体和粗体。</p><p>示例：</p><p>这是 <em>斜体</em>，这是 <strong>粗体</strong>。</p><h3 id="分级标题">2. 分级标题</h3><p>使用 === 表示一级标题，使用 --- 表示二级标题。</p><p>示例：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">这是一个一级标题</span><br><span class="hljs-section">============================</span><br><br><span class="hljs-section">这是一个二级标题</span><br><span class="hljs-section">--------------------------------------------------</span><br><br>### 这是一个三级标题<br></code></pre></td></tr></table></figure><p>你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ##H2, ### H3，#### H4。</p><h3 id="外链接">3. 外链接</h3><p>使用 [描述](链接地址) 为文字增加外链接。</p><p>示例：</p><p>这是去往 <a href="http://ghosertblog.github.com">本人博客</a>的链接。</p><h3 id="无序列表">4. 无序列表</h3><p>使用 *，+，- 表示无序列表。</p><p>示例：</p><ul><li>无序列表项 一</li><li>无序列表项 二</li><li>无序列表项 三</li></ul><h3 id="有序列表">5. 有序列表</h3><p>使用数字和点表示有序列表。</p><p>示例：</p><ol type="1"><li>有序列表项 一</li><li>有序列表项 二</li><li>有序列表项 三</li></ol><h3 id="文字引用">6. 文字引用</h3><p>使用 &gt; 表示文字引用。</p><p>示例：</p><blockquote><p>野火烧不尽，春风吹又生。</p></blockquote><h3 id="行内代码块">7. 行内代码块</h3><p>使用 `代码` 表示行内代码块。</p><p>示例：</p><p>让我们聊聊 <code>html</code>。</p><h3 id="代码块">8. 代码块</h3><p>使用 四个缩进空格 表示代码块。</p><p>示例：</p><pre><code class="hljs">这是一个代码块，此行左侧有四个不可见的空格。</code></pre><h3 id="插入图像">9. 插入图像</h3><p>使用 ![描述](图片链接地址) 插入图像。</p><p>示例：</p><figure><img src="https://wallhaven.cc/w/vqy5p8" alt="我的头像"><figcaption aria-hidden="true">我的头像</figcaption></figure><h1 id="markdown-高阶语法手册">Markdown 高阶语法手册</h1><h3 id="内容目录">1. 内容目录</h3><p>在段落中填写 <code>[TOC]</code> 以显示全文内容的目录结构。</p><p>[TOC]</p><h3 id="标签分类">2. 标签分类</h3><p>在编辑区任意行的列首位置输入以下代码给文稿标签：</p><p>标签： 数学 英语 Markdown</p><p>或者</p><p>Tags： 数学 英语 Markdown</p><h3 id="删除线">3. 删除线</h3><p>使用 ~~ 表示删除线。</p><p><del>这是一段错误的文本。</del></p><h3 id="注脚">4. 注脚</h3><p>使用 [^keyword] 表示注脚。</p><p>这是一个注脚<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>的样例。</p><p>这是第二个注脚<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>的样例。</p><h3 id="latex-公式">5. LaTeX 公式</h3><p><code>$</code> 表示行内公式：</p><p>质能守恒方程可以用一个很简洁的方程式 <span class="math inline">\(E=mc^2\)</span> 来表达。</p><p><code>$$</code> 表示整行公式：</p><p><span class="math display">\[\sum_{i=1}^n a_i=0\]</span></p><p><span class="math display">\[f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 +\cdots + x_n^2\]</span></p><p><span class="math display">\[\sum^{j-1}_{k=0} {\widehat{\gamma}_{kj}z_k}\]</span></p><p>访问 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference">MathJax</a>参考更多使用方法。</p><h3 id="加强的代码块">6. 加强的代码块</h3><p>支持四十一种编程语言的语法高亮的显示，行号显示。</p><p>非代码示例：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ sudo apt-<span class="hljs-built_in">get</span> install vim-gnome<br></code></pre></td></tr></table></figure><p>Python 示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@requires_authorization</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">somefunc</span>(<span class="hljs-params">param1=<span class="hljs-string">&#x27;&#x27;</span>, param2=<span class="hljs-number">0</span></span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;A docstring&#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">if</span> param1 &gt; param2: <span class="hljs-comment"># interesting</span><br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Greater&#x27;</span><br>    <span class="hljs-keyword">return</span> (param2 - param1 + <span class="hljs-number">1</span>) <span class="hljs-keyword">or</span> <span class="hljs-literal">None</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeClass</span>:<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>message = <span class="hljs-string">&#x27;&#x27;&#x27;interpreter</span><br><span class="hljs-string"><span class="hljs-meta">... </span>prompt&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>JavaScript 示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* nth element in the fibonacci series.</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> n &gt;= 0</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span> the nth element, &gt;= 0.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fib</span>(<span class="hljs-params">n</span>) &#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">var</span> tmp;<br>  <span class="hljs-keyword">while</span> (--n &gt;= <span class="hljs-number">0</span>) &#123;<br>    tmp = a;<br>    a += b;<br>    b = tmp;<br>  &#125;<br>  <span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-title function_">fib</span>(<span class="hljs-number">10</span>));<br></code></pre></td></tr></table></figure><h3 id="流程图">7. 流程图</h3><h4 id="示例">示例</h4><div id="flowchart-0" class="flow-chart"></div><h3 id="表格支持">8. 表格支持</h3><table><thead><tr class="header"><th>项目</th><th style="text-align: right;">价格</th><th style="text-align: center;">数量</th></tr></thead><tbody><tr class="odd"><td>计算机</td><td style="text-align: right;">$1600</td><td style="text-align: center;">5</td></tr><tr class="even"><td>手机</td><td style="text-align: right;">$12</td><td style="text-align: center;">12</td></tr><tr class="odd"><td>管线</td><td style="text-align: right;">$1</td><td style="text-align: center;">234</td></tr></tbody></table><h3 id="定义型列表">9. 定义型列表</h3><dl><dt>名词 1</dt><dd>定义 1（左侧有一个可见的冒号和四个不可见的空格）</dd><dt>代码块 2</dt><dd><p>这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）</p><pre><code class="hljs">代码块（左侧有八个不可见的空格）</code></pre></dd></dl><h3 id="html-标签">10. Html 标签</h3><p>本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html写一个纵跨两行的表格：</p><pre><code class="hljs">&lt;table&gt;    &lt;tr&gt;        &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt;        &lt;th&gt;星期一&lt;/th&gt;        &lt;th&gt;星期二&lt;/th&gt;        &lt;th&gt;星期三&lt;/th&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;李强&lt;/td&gt;        &lt;td&gt;张明&lt;/td&gt;        &lt;td&gt;王平&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;</code></pre><table><tr><th rowspan="2">值班人员</th><th>星期一</th><th>星期二</th><th>星期三</th></tr><tr><td>李强</td><td>张明</td><td>王平</td></tr></table><h3 id="内嵌图标">11. 内嵌图标</h3><p>本站的图标系统对外开放，在文档中输入</p><pre><code class="hljs">&lt;i class=&quot;icon-weibo&quot;&gt;&lt;/i&gt;</code></pre><p>即显示微博的图标： <i class="icon-weibo icon-2x"></i></p><p>替换 上述 <code>i 标签</code> 内的 <code>icon-weibo</code>以显示不同的图标，例如：</p><pre><code class="hljs">&lt;i class=&quot;icon-renren&quot;&gt;&lt;/i&gt;</code></pre><p>即显示人人的图标： <i class="icon-renren icon-2x"></i></p><p>更多的图标和玩法可以参看 <a href="http://fortawesome.github.io/Font-Awesome/3.2.1/icons/">font-awesome</a>官方网站。</p><h3 id="待办事宜-todo-列表">12. 待办事宜 Todo 列表</h3><p>使用带有 [ ] 或 [x]（未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如：</p><pre><code class="hljs">- [ ] **Markdown 开发**    - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率    - [ ] 支持以 PDF 格式导出文稿    - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments)    - [x] 改进 LaTex 功能        - [x] 修复 LaTex 公式渲染问题        - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers)</code></pre><p>对应显示如下待办事宜 Todo 列表：</p><ul class="task-list"><li><input type="checkbox"><strong>Markdown 开发</strong><ul class="task-list"><li><input type="checkbox">改进 Cmd渲染算法，使用局部渲染技术提高渲染效率</li><li><input type="checkbox">支持以 PDF 格式导出文稿</li><li><input type="checkbox" checked>新增Todo列表功能 <a href="https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments">语法参考</a></li><li><input type="checkbox" checked>改进 LaTex 功能<ul class="task-list"><li><input type="checkbox" checked>修复 LaTex 公式渲染问题</li><li><input type="checkbox" checked>新增 LaTex 公式编号功能 <a href="http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers">语法参考</a></li></ul></li></ul></li></ul><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: Start:>https://www.zybuluo.comio=>inputoutput: verificationop=>operation: Your Operationcond=>condition: Yes or No?sub=>subroutine: Your Subroutinee=>endst->io->op->condcond(yes)->econd(no)->sub->io</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><aside id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p>这是一个 <em>注脚</em> 的 <strong>文本</strong>。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2"><p>这是另一个 <em>注脚</em> 的 <strong>文本</strong>。<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></aside>]]></content>
    
    
    <categories>
      
      <category>markdown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>New Start</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/05/09/hello-world/"/>
    <url>/2023/05/09/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
